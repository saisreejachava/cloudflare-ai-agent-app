{"version":3,"file":"index.js","names":["#cache","state: T","setState","state: DurableObjectState","tag?: string","socket: WebSocket","#connections","controller: DurableObjectState","record: Record<string, string>","defaultEnv","env","#ParentClass","#_props","#_name","#status","#initialize","connection: Connection","state: T","#connectionManager","#attachSocketEventHandlers","error: unknown","e","#_longErrorAboutNameThrown","#sendMessageToConnection"],"sources":["../src/connection.ts","../src/index.ts"],"sourcesContent":["// Polyfill WebSocket status code constants for environments that don't have them\n// in order to support libraries that expect standards-compatible WebSocket\n// implementations (e.g. PartySocket)\n\nimport type {\n  Connection,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nif (!(\"OPEN\" in WebSocket)) {\n  const WebSocketStatus = {\n    // @ts-expect-error\n    CONNECTING: WebSocket.READY_STATE_CONNECTING,\n    // @ts-expect-error\n    OPEN: WebSocket.READY_STATE_OPEN,\n    // @ts-expect-error\n    CLOSING: WebSocket.READY_STATE_CLOSING,\n    // @ts-expect-error\n    CLOSED: WebSocket.READY_STATE_CLOSED\n  };\n\n  Object.assign(WebSocket, WebSocketStatus);\n  // @ts-expect-error\n  Object.assign(WebSocket.prototype, WebSocketStatus);\n}\n\n/**\n * Store both platform attachments and user attachments in different namespaces\n */\ntype ConnectionAttachments = {\n  __pk: {\n    id: string;\n    // TODO: remove this once we have\n    // durable object level setState\n    server: string;\n  };\n  __user?: unknown;\n};\n\nfunction tryGetPartyServerMeta(\n  ws: WebSocket\n): ConnectionAttachments[\"__pk\"] | null {\n  try {\n    // Avoid AttachmentCache.get() here: hibernated sockets accepted outside\n    // PartyServer can have an attachment without a __pk namespace.\n    const attachment = WebSocket.prototype.deserializeAttachment.call(\n      ws\n    ) as unknown;\n    if (!attachment || typeof attachment !== \"object\") {\n      return null;\n    }\n    if (!(\"__pk\" in attachment)) {\n      return null;\n    }\n    const pk = (attachment as ConnectionAttachments).__pk as unknown;\n    if (!pk || typeof pk !== \"object\") {\n      return null;\n    }\n    const { id, server } = pk as { id?: unknown; server?: unknown };\n    if (typeof id !== \"string\" || typeof server !== \"string\") {\n      return null;\n    }\n    return pk as ConnectionAttachments[\"__pk\"];\n  } catch {\n    return null;\n  }\n}\n\nexport function isPartyServerWebSocket(ws: WebSocket): boolean {\n  return tryGetPartyServerMeta(ws) !== null;\n}\n\n/**\n * Cache websocket attachments to avoid having to rehydrate them on every property access.\n */\nclass AttachmentCache {\n  #cache = new WeakMap<WebSocket, ConnectionAttachments>();\n\n  get(ws: WebSocket): ConnectionAttachments {\n    let attachment = this.#cache.get(ws);\n    if (!attachment) {\n      attachment = WebSocket.prototype.deserializeAttachment.call(\n        ws\n      ) as ConnectionAttachments;\n      if (attachment !== undefined) {\n        this.#cache.set(ws, attachment);\n      } else {\n        throw new Error(\n          \"Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/cloudflare/partykit/issues\"\n        );\n      }\n    }\n\n    return attachment;\n  }\n\n  set(ws: WebSocket, attachment: ConnectionAttachments) {\n    this.#cache.set(ws, attachment);\n    WebSocket.prototype.serializeAttachment.call(ws, attachment);\n  }\n}\n\nconst attachments = new AttachmentCache();\nconst connections = new WeakSet<Connection>();\nconst isWrapped = (ws: WebSocket): ws is Connection => {\n  return connections.has(ws as Connection);\n};\n\n/**\n * Wraps a WebSocket with Connection fields that rehydrate the\n * socket attachments lazily only when requested.\n */\nexport const createLazyConnection = (\n  ws: WebSocket | Connection\n): Connection => {\n  if (isWrapped(ws)) {\n    return ws;\n  }\n\n  // if state was set on the socket before initializing the connection,\n  // capture it here so we can persist it again\n  // biome-ignore lint/suspicious/noImplicitAnyLet: it's fine\n  let initialState;\n  if (\"state\" in ws) {\n    initialState = ws.state;\n    delete ws.state;\n  }\n\n  const connection = Object.defineProperties(ws, {\n    id: {\n      get() {\n        return attachments.get(ws).__pk.id;\n      }\n    },\n    server: {\n      get() {\n        return attachments.get(ws).__pk.server;\n      }\n    },\n    socket: {\n      get() {\n        return ws;\n      }\n    },\n    state: {\n      configurable: true,\n      get() {\n        return ws.deserializeAttachment() as ConnectionState<unknown>;\n      }\n    },\n    setState: {\n      configurable: true,\n      value: function setState<T>(setState: T | ConnectionSetStateFn<T>) {\n        let state: T;\n        if (setState instanceof Function) {\n          state = setState((this as Connection<T>).state);\n        } else {\n          state = setState;\n        }\n\n        ws.serializeAttachment(state);\n        return state as ConnectionState<T>;\n      }\n    },\n\n    deserializeAttachment: {\n      configurable: true,\n      value: function deserializeAttachment<T = unknown>() {\n        const attachment = attachments.get(ws);\n        return (attachment.__user ?? null) as T;\n      }\n    },\n\n    serializeAttachment: {\n      configurable: true,\n      value: function serializeAttachment<T = unknown>(attachment: T) {\n        const setting = {\n          ...attachments.get(ws),\n          __user: attachment ?? null\n        };\n\n        attachments.set(ws, setting);\n      }\n    }\n  }) as Connection;\n\n  if (initialState) {\n    connection.setState(initialState);\n  }\n\n  connections.add(connection);\n  return connection;\n};\n\nclass HibernatingConnectionIterator<T> implements IterableIterator<\n  Connection<T>\n> {\n  private index = 0;\n  private sockets: WebSocket[] | undefined;\n  constructor(\n    private state: DurableObjectState,\n    private tag?: string\n  ) {}\n\n  [Symbol.iterator](): IterableIterator<Connection<T>> {\n    return this;\n  }\n\n  next(): IteratorResult<Connection<T>, number | undefined> {\n    const sockets =\n      // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));\n\n    let socket: WebSocket;\n    // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n    while ((socket = sockets[this.index++])) {\n      // only yield open sockets to match non-hibernating behaviour\n      if (socket.readyState === WebSocket.READY_STATE_OPEN) {\n        // Durable Objects hibernation APIs allow storing arbitrary sockets via\n        // `state.acceptWebSocket()`. Those sockets won't have PartyServer's\n        // `__pk` attachment namespace and must be ignored.\n        if (!isPartyServerWebSocket(socket)) {\n          continue;\n        }\n        const value = createLazyConnection(socket) as Connection<T>;\n        return { done: false, value };\n      }\n    }\n\n    // reached the end of the iteratee\n    return { done: true, value: undefined };\n  }\n}\n\nexport interface ConnectionManager {\n  getCount(): number;\n  getConnection<TState>(id: string): Connection<TState> | undefined;\n  getConnections<TState>(tag?: string): IterableIterator<Connection<TState>>;\n  accept(\n    connection: Connection,\n    options: { tags: string[]; server: string }\n  ): Connection;\n}\n\n/**\n * When not using hibernation, we track active connections manually.\n */\nexport class InMemoryConnectionManager<TState> implements ConnectionManager {\n  #connections: Map<string, Connection> = new Map();\n  tags: WeakMap<Connection, string[]> = new WeakMap();\n\n  getCount() {\n    return this.#connections.size;\n  }\n\n  getConnection<T = TState>(id: string) {\n    return this.#connections.get(id) as Connection<T> | undefined;\n  }\n\n  *getConnections<T = TState>(tag?: string): IterableIterator<Connection<T>> {\n    if (!tag) {\n      yield* this.#connections\n        .values()\n        .filter(\n          (c) => c.readyState === WebSocket.READY_STATE_OPEN\n        ) as IterableIterator<Connection<T>>;\n      return;\n    }\n\n    // simulate DurableObjectState.getWebSockets(tag) behaviour\n    for (const connection of this.#connections.values()) {\n      const connectionTags = this.tags.get(connection) ?? [];\n      if (connectionTags.includes(tag)) {\n        yield connection as Connection<T>;\n      }\n    }\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    connection.accept();\n\n    this.#connections.set(connection.id, connection);\n    this.tags.set(connection, [\n      // make sure we have id tag\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ]);\n\n    const removeConnection = () => {\n      this.#connections.delete(connection.id);\n      connection.removeEventListener(\"close\", removeConnection);\n      connection.removeEventListener(\"error\", removeConnection);\n    };\n    connection.addEventListener(\"close\", removeConnection);\n    connection.addEventListener(\"error\", removeConnection);\n\n    return connection;\n  }\n}\n\n/**\n * When opting into hibernation, the platform tracks connections for us.\n */\nexport class HibernatingConnectionManager<TState> implements ConnectionManager {\n  constructor(private controller: DurableObjectState) {}\n\n  getCount() {\n    // Only count sockets managed by PartyServer. Other hibernated sockets may\n    // exist on the same Durable Object via `state.acceptWebSocket()`.\n    let count = 0;\n    for (const ws of this.controller.getWebSockets()) {\n      if (isPartyServerWebSocket(ws)) count++;\n    }\n    return count;\n  }\n\n  getConnection<T = TState>(id: string) {\n    // TODO: Should we cache the connections?\n    const sockets = this.controller.getWebSockets(id);\n    const matching = sockets.filter((ws) => {\n      return tryGetPartyServerMeta(ws)?.id === id;\n    });\n\n    if (matching.length === 0) return undefined;\n    if (matching.length === 1)\n      return createLazyConnection(matching[0]) as Connection<T>;\n\n    throw new Error(\n      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`\n    );\n  }\n\n  getConnections<T = TState>(tag?: string | undefined) {\n    return new HibernatingConnectionIterator<T>(this.controller, tag);\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    // dedupe tags in case user already provided id tag\n    const tags = [\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ];\n\n    // validate tags against documented restrictions\n    // shttps://developers.cloudflare.com/durable-objects/api/hibernatable-websockets-api/#state-methods-for-websockets\n    if (tags.length > 10) {\n      throw new Error(\n        \"A connection can only have 10 tags, including the default id tag.\"\n      );\n    }\n\n    for (const tag of tags) {\n      if (typeof tag !== \"string\") {\n        throw new Error(`A connection tag must be a string. Received: ${tag}`);\n      }\n      if (tag === \"\") {\n        throw new Error(\"A connection tag must not be an empty string.\");\n      }\n      if (tag.length > 256) {\n        throw new Error(\"A connection tag must not exceed 256 characters\");\n      }\n    }\n\n    this.controller.acceptWebSocket(connection, tags);\n    connection.serializeAttachment({\n      __pk: {\n        id: connection.id,\n        server: options.server\n      },\n      __user: null\n    });\n\n    return createLazyConnection(connection);\n  }\n}\n","// rethink error handling, how to pass it on to the client\n// rethink oBC/oBR\n// push for durable.setState (in addition to connection.setState)\n\nimport { DurableObject, env as defaultEnv } from \"cloudflare:workers\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  createLazyConnection,\n  HibernatingConnectionManager,\n  InMemoryConnectionManager,\n  isPartyServerWebSocket\n} from \"./connection\";\n\nimport type { ConnectionManager } from \"./connection\";\nimport type {\n  Connection,\n  ConnectionContext,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nexport * from \"./types\";\n\nexport type WSMessage = ArrayBuffer | ArrayBufferView | string;\n\n// Let's cache the server namespace map\n// so we don't call it on every request\nconst serverMapCache = new WeakMap<\n  object,\n  Record<string, DurableObjectNamespace>\n>();\n\n/**\n * For a given server namespace, create a server with a name.\n */\nexport async function getServerByName<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  T extends Server<Env> = Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  serverNamespace: DurableObjectNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n    props?: Props;\n  }\n): Promise<DurableObjectStub<T>> {\n  if (options?.jurisdiction) {\n    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);\n  }\n\n  const id = serverNamespace.idFromName(name);\n  const stub = serverNamespace.get(id, options);\n\n  // TODO: fix this to use RPC\n\n  const req = new Request(\n    \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/\"\n  );\n\n  req.headers.set(\"x-partykit-room\", name);\n\n  if (options?.props) {\n    req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n  }\n\n  // unfortunately we have to await this\n  await stub.fetch(req).then((res) => res.text());\n\n  return stub;\n}\n\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\nexport interface PartyServerOptions<\n  // biome-ignore lint/correctness/noUnusedVariables: it's ok, we'll remove this in the next major\n  Env = Cloudflare.Env,\n  Props = Record<string, unknown>\n> {\n  prefix?: string;\n  jurisdiction?: DurableObjectJurisdiction;\n  locationHint?: DurableObjectLocationHint;\n  props?: Props;\n  /**\n   * Whether to enable CORS for matched routes.\n   *\n   * When `true`, uses default permissive CORS headers:\n   * - Access-Control-Allow-Origin: *\n   * - Access-Control-Allow-Methods: GET, POST, HEAD, OPTIONS\n   * - Access-Control-Allow-Headers: *\n   * - Access-Control-Max-Age: 86400\n   *\n   * For credentialed requests, pass explicit headers with a specific origin:\n   * ```ts\n   * cors: {\n   *   \"Access-Control-Allow-Origin\": \"https://myapp.com\",\n   *   \"Access-Control-Allow-Credentials\": \"true\",\n   *   \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n   *   \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\"\n   * }\n   * ```\n   *\n   * When set to a `HeadersInit` value, uses those as the CORS headers instead.\n   * CORS preflight (OPTIONS) requests are handled automatically for matched routes.\n   * Non-WebSocket responses on matched routes will also have the CORS headers appended.\n   */\n  cors?: boolean | HeadersInit;\n  onBeforeConnect?: (\n    req: Request,\n    lobby: {\n      party: string;\n      name: string;\n    }\n  ) => Response | Request | void | Promise<Response | Request | void>;\n  onBeforeRequest?: (\n    req: Request,\n    lobby: {\n      party: string;\n      name: string;\n    }\n  ) =>\n    | Response\n    | Request\n    | void\n    | Promise<Response | Request | undefined | void>;\n}\n/**\n * Resolve CORS options into a concrete headers object (or null if CORS is disabled).\n */\nfunction resolveCorsHeaders(\n  cors: boolean | HeadersInit | undefined\n): Record<string, string> | null {\n  if (cors === true) {\n    return {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"*\",\n      \"Access-Control-Max-Age\": \"86400\"\n    };\n  }\n  if (cors && typeof cors === \"object\") {\n    // Convert any HeadersInit shape to a plain record\n    const h = new Headers(cors as HeadersInit);\n    const record: Record<string, string> = {};\n    h.forEach((value, key) => {\n      record[key] = value;\n    });\n    return record;\n  }\n  return null;\n}\n\nexport async function routePartykitRequest<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  T extends Server<Env> = Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  req: Request,\n  env: Env = defaultEnv as Env,\n  options?: PartyServerOptions<Env, Props>\n): Promise<Response | null> {\n  if (!serverMapCache.has(env)) {\n    serverMapCache.set(\n      env,\n      Object.entries(env).reduce((acc, [k, v]) => {\n        if (\n          v &&\n          typeof v === \"object\" &&\n          \"idFromName\" in v &&\n          typeof v.idFromName === \"function\"\n        ) {\n          Object.assign(acc, { [camelCaseToKebabCase(k)]: v });\n          return acc;\n        }\n        return acc;\n      }, {})\n    );\n  }\n  const map = serverMapCache.get(env) as unknown as Record<\n    string,\n    DurableObjectNamespace<T>\n  >;\n\n  const prefix = options?.prefix || \"parties\";\n  const prefixParts = prefix.split(\"/\");\n\n  const url = new URL(req.url);\n  const parts = url.pathname.split(\"/\").filter(Boolean); // Remove empty strings\n\n  // Check if the URL starts with the prefix\n  const prefixMatches = prefixParts.every(\n    (part, index) => parts[index] === part\n  );\n  if (!prefixMatches || parts.length < prefixParts.length + 2) {\n    return null;\n  }\n\n  const namespace = parts[prefixParts.length];\n  const name = parts[prefixParts.length + 1];\n\n  if (name && namespace) {\n    if (!map[namespace]) {\n      if (namespace === \"main\") {\n        console.warn(\n          \"You appear to be migrating a PartyKit project to PartyServer.\"\n        );\n        console.warn(`PartyServer doesn't have a \"main\" party by default. Try adding this to your PartySocket client:\\n \nparty: \"${camelCaseToKebabCase(Object.keys(map)[0])}\"`);\n      } else {\n        console.error(`The url ${req.url}  with namespace \"${namespace}\" and name \"${name}\" does not match any server namespace. \nDid you forget to add a durable object binding to the class ${namespace[0].toUpperCase() + namespace.slice(1)} in your wrangler.jsonc?`);\n      }\n      // we should return a response with a status code that it's an invalid request\n      return new Response(\"Invalid request\", { status: 400 });\n    }\n\n    // Resolve CORS headers for this matched route\n    const corsHeaders = resolveCorsHeaders(options?.cors);\n    const isWebSocket =\n      req.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\";\n\n    // Helper: append CORS headers to a response (skipped for WebSocket upgrades)\n    function withCorsHeaders(response: Response): Response {\n      if (!corsHeaders || isWebSocket) return response;\n      const newResponse = new Response(response.body, response);\n      for (const [key, value] of Object.entries(corsHeaders)) {\n        newResponse.headers.set(key, value);\n      }\n      return newResponse;\n    }\n\n    // Handle CORS preflight requests for matched routes\n    if (req.method === \"OPTIONS\" && corsHeaders) {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    let doNamespace = map[namespace];\n    if (options?.jurisdiction) {\n      doNamespace = doNamespace.jurisdiction(options.jurisdiction);\n    }\n\n    const id = doNamespace.idFromName(name);\n    const stub = doNamespace.get(id, options);\n\n    // const stub = await getServerByName(map[namespace], name, options); // TODO: fix this\n    // make a new request with additional headers\n\n    req = new Request(req);\n    req.headers.set(\"x-partykit-room\", name);\n    req.headers.set(\"x-partykit-namespace\", namespace);\n    if (options?.jurisdiction) {\n      req.headers.set(\"x-partykit-jurisdiction\", options.jurisdiction);\n    }\n\n    if (options?.props) {\n      req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n    }\n\n    if (isWebSocket) {\n      if (options?.onBeforeConnect) {\n        const reqOrRes = await options.onBeforeConnect(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    } else {\n      if (options?.onBeforeRequest) {\n        const reqOrRes = await options.onBeforeRequest(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return withCorsHeaders(reqOrRes);\n        }\n      }\n    }\n\n    return withCorsHeaders(await stub.fetch(req));\n  } else {\n    return null;\n  }\n}\n\nexport class Server<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends DurableObject<Env> {\n  static options: { hibernate?: boolean } = {\n    hibernate: false\n  };\n\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n\n  #ParentClass: typeof Server = Object.getPrototypeOf(this).constructor;\n\n  #connectionManager: ConnectionManager = this.#ParentClass.options.hibernate\n    ? new HibernatingConnectionManager(this.ctx)\n    : new InMemoryConnectionManager();\n\n  /**\n   * Execute SQL queries against the Server's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onException(e);\n    }\n  }\n\n  // biome-ignore lint/complexity/noUselessConstructor: it's fine\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n\n    // TODO: throw error if any of\n    // broadcast/getConnection/getConnections/getConnectionTags\n    // fetch/webSocketMessage/webSocketClose/webSocketError/alarm\n    // have been overridden\n  }\n\n  /**\n   * Handle incoming requests to the server.\n   */\n  async fetch(request: Request): Promise<Response> {\n    try {\n      // Set the props in-mem if the request included them.\n      const props = request.headers.get(\"x-partykit-props\");\n      if (props) {\n        this.#_props = JSON.parse(props);\n      }\n      if (!this.#_name) {\n        // This is temporary while we solve https://github.com/cloudflare/workerd/issues/2240\n\n        // get namespace and room from headers\n        // const namespace = request.headers.get(\"x-partykit-namespace\");\n        const room = request.headers.get(\"x-partykit-room\");\n        if (\n          // !namespace ||\n          !room\n        ) {\n          throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.\nDid you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);\n        }\n        await this.setName(room);\n      } else if (this.#status !== \"started\") {\n        // Name was set by a previous request but initialization failed.\n        // Retry initialization so the server can recover from transient\n        // onStart failures.\n        await this.#initialize();\n      }\n      const url = new URL(request.url);\n\n      // TODO: this is a hack to set the server name,\n      // it'll be replaced with RPC later\n      if (url.pathname === \"/cdn-cgi/partyserver/set-name/\") {\n        // we can just return a 200 for now\n        return Response.json({ ok: true });\n      }\n\n      if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n        return await this.onRequest(request);\n      } else {\n        // Create the websocket pair for the client\n        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();\n        let connectionId = url.searchParams.get(\"_pk\");\n        if (!connectionId) {\n          connectionId = nanoid();\n        }\n\n        let connection: Connection = Object.assign(serverWebSocket, {\n          id: connectionId,\n          server: this.name,\n          state: null as unknown as ConnectionState<unknown>,\n          setState<T = unknown>(setState: T | ConnectionSetStateFn<T>) {\n            let state: T;\n            if (setState instanceof Function) {\n              state = setState(this.state as ConnectionState<T>);\n            } else {\n              state = setState;\n            }\n\n            // TODO: deepFreeze object?\n            this.state = state as ConnectionState<T>;\n            return this.state;\n          }\n        });\n\n        const ctx = { request };\n\n        const tags = await this.getConnectionTags(connection, ctx);\n\n        // Accept the websocket connection\n        connection = this.#connectionManager.accept(connection, {\n          tags,\n          server: this.name\n        });\n\n        if (!this.#ParentClass.options.hibernate) {\n          this.#attachSocketEventHandlers(connection);\n        }\n        await this.onConnect(connection, ctx);\n\n        return new Response(null, { status: 101, webSocket: clientWebSocket });\n      }\n    } catch (err) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.#_name ?? \"<unnamed>\"} fetch:`,\n        err\n      );\n      if (!(err instanceof Error)) throw err;\n      if (request.headers.get(\"Upgrade\") === \"websocket\") {\n        // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n        // won't show us the response body! So... let's send a WebSocket response with an error\n        // frame instead.\n        const pair = new WebSocketPair();\n        pair[1].accept();\n        pair[1].send(JSON.stringify({ error: err.stack }));\n        pair[1].close(1011, \"Uncaught exception during session setup\");\n        return new Response(null, { status: 101, webSocket: pair[0] });\n      } else {\n        return new Response(err.stack, { status: 500 });\n      }\n    }\n  }\n\n  async webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void> {\n    // Ignore websockets accepted outside PartyServer (e.g. via\n    // `state.acceptWebSocket()` in user code). These sockets won't have the\n    // `__pk` attachment namespace required to rehydrate a Connection.\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    try {\n      const connection = createLazyConnection(ws);\n\n      // rehydrate the server name if it's woken up\n      await this.setName(connection.server);\n      // TODO: ^ this shouldn't be async\n\n      return this.onMessage(connection, message);\n    } catch (e) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.#_name ?? \"<unnamed>\"} webSocketMessage:`,\n        e\n      );\n    }\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    try {\n      const connection = createLazyConnection(ws);\n\n      // rehydrate the server name if it's woken up\n      await this.setName(connection.server);\n      // TODO: ^ this shouldn't be async\n\n      return this.onClose(connection, code, reason, wasClean);\n    } catch (e) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.#_name ?? \"<unnamed>\"} webSocketClose:`,\n        e\n      );\n    }\n  }\n\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    try {\n      const connection = createLazyConnection(ws);\n\n      // rehydrate the server name if it's woken up\n      await this.setName(connection.server);\n      // TODO: ^ this shouldn't be async\n\n      return this.onError(connection, error);\n    } catch (e) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.#_name ?? \"<unnamed>\"} webSocketError:`,\n        e\n      );\n    }\n  }\n\n  async #initialize(): Promise<void> {\n    let error: unknown;\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      try {\n        await this.onStart(this.#_props);\n        this.#status = \"started\";\n      } catch (e) {\n        this.#status = \"zero\";\n        error = e;\n      }\n    });\n    // Re-throw outside blockConcurrencyWhile so the DO's input gate\n    // isn't permanently broken, allowing subsequent requests to retry.\n    if (error) throw error;\n  }\n\n  #attachSocketEventHandlers(connection: Connection) {\n    const handleMessageFromClient = (event: MessageEvent) => {\n      this.onMessage(connection, event.data)?.catch<void>((e) => {\n        console.error(\"onMessage error:\", e);\n      });\n    };\n\n    const handleCloseFromClient = (event: CloseEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"close\", handleCloseFromClient);\n      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(\n        (e) => {\n          console.error(\"onClose error:\", e);\n        }\n      );\n    };\n\n    const handleErrorFromClient = (e: ErrorEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"error\", handleErrorFromClient);\n      this.onError(connection, e.error)?.catch((e) => {\n        console.error(\"onError error:\", e);\n      });\n    };\n\n    connection.addEventListener(\"close\", handleCloseFromClient);\n    connection.addEventListener(\"error\", handleErrorFromClient);\n    connection.addEventListener(\"message\", handleMessageFromClient);\n  }\n\n  // Public API\n\n  #_name: string | undefined;\n\n  #_longErrorAboutNameThrown = false;\n  /**\n   * The name for this server. Write-once-only.\n   */\n  get name(): string {\n    if (!this.#_name) {\n      if (!this.#_longErrorAboutNameThrown) {\n        this.#_longErrorAboutNameThrown = true;\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`\n        );\n      } else {\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`\n        );\n      }\n    }\n    return this.#_name;\n  }\n\n  // We won't have an await inside this function\n  // but it will be called remotely,\n  // so we need to mark it as async\n  async setName(name: string) {\n    if (!name) {\n      throw new Error(\"A name is required.\");\n    }\n    if (this.#_name && this.#_name !== name) {\n      throw new Error(\n        `This server already has a name: ${this.#_name}, attempting to set to: ${name}`\n      );\n    }\n    this.#_name = name;\n\n    if (this.#status !== \"started\") {\n      await this.#initialize();\n    }\n  }\n\n  #sendMessageToConnection(connection: Connection, message: WSMessage): void {\n    try {\n      connection.send(message);\n    } catch (_e) {\n      // close connection\n      connection.close(1011, \"Unexpected error\");\n    }\n  }\n\n  /** Send a message to all connected clients, except connection ids listed in `without` */\n  broadcast(\n    msg: string | ArrayBuffer | ArrayBufferView,\n    without?: string[] | undefined\n  ): void {\n    for (const connection of this.#connectionManager.getConnections()) {\n      if (!without || !without.includes(connection.id)) {\n        this.#sendMessageToConnection(connection, msg);\n      }\n    }\n  }\n\n  /** Get a connection by connection id */\n  getConnection<TState = unknown>(id: string): Connection<TState> | undefined {\n    return this.#connectionManager.getConnection<TState>(id);\n  }\n\n  /**\n   * Get all connections. Optionally, you can provide a tag to filter returned connections.\n   * Use `Server#getConnectionTags` to tag the connection on connect.\n   */\n  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>> {\n    return this.#connectionManager.getConnections<TState>(tag);\n  }\n\n  /**\n   * You can tag a connection to filter them in Server#getConnections.\n   * Each connection supports up to 9 tags, each tag max length is 256 characters.\n   */\n  getConnectionTags(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    context: ConnectionContext\n  ): string[] | Promise<string[]> {\n    return [];\n  }\n\n  #_props?: Props;\n\n  // Implemented by the user\n\n  /**\n   * Called when the server is started for the first time.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onStart(props?: Props): void | Promise<void> {}\n\n  /**\n   * Called when a new connection is made to the server.\n   */\n  onConnect(\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    ctx: ConnectionContext\n  ): void | Promise<void> {\n    console.log(\n      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`\n    );\n    // console.log(\n    //   `Implement onConnect on ${this.#ParentClass.name} to handle websocket connections.`\n    // );\n  }\n\n  /**\n   * Called when a message is received from a connection.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onMessage(connection: Connection, message: WSMessage): void | Promise<void> {\n    console.log(\n      `Received message on connection ${this.#ParentClass.name}:${connection.id}`\n    );\n    console.info(\n      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`\n    );\n  }\n\n  /**\n   * Called when a connection is closed.\n   */\n  onClose(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    code: number,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    reason: string,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    wasClean: boolean\n  ): void | Promise<void> {}\n\n  /**\n   * Called when an error occurs on a connection.\n   */\n  onError(connection: Connection, error: unknown): void | Promise<void> {\n    console.error(\n      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onError on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  /**\n   * Called when a request is made to the server.\n   */\n  onRequest(request: Request): Response | Promise<Response> {\n    // default to 404\n\n    console.warn(\n      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`\n    );\n\n    return new Response(\"Not implemented\", { status: 404 });\n  }\n\n  /**\n   * Called when an exception occurs.\n   * @param error - The error that occurred.\n   */\n  onException(error: unknown): void | Promise<void> {\n    console.error(\n      `Exception in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onException on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  onAlarm(): void | Promise<void> {\n    console.log(\n      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`\n    );\n  }\n\n  async alarm(): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    await this.onAlarm();\n  }\n}\n"],"mappings":"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"}