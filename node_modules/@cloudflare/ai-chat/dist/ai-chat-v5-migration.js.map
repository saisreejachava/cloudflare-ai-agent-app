{"version":3,"file":"ai-chat-v5-migration.js","names":[],"sources":["../src/ai-chat-v5-migration.ts"],"sourcesContent":["import type { UIMessage } from \"ai\";\n\n/**\n * AI SDK v5 Migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n * Using exact types from the official AI SDK documentation\n */\n\n/**\n * AI SDK v5 Message Part types reference (from official AI SDK documentation)\n *\n * The migration logic below transforms legacy messages to match these official AI SDK v5 formats:\n * - TextUIPart: { type: \"text\", text: string, state?: \"streaming\" | \"done\" }\n * - ReasoningUIPart: { type: \"reasoning\", text: string, state?: \"streaming\" | \"done\", providerMetadata?: Record<string, unknown> }\n * - FileUIPart: { type: \"file\", mediaType: string, filename?: string, url: string }\n * - ToolUIPart: { type: `tool-${string}`, toolCallId: string, state: \"input-streaming\" | \"input-available\" | \"output-available\" | \"output-error\", input?: Record<string, unknown>, output?: unknown, errorText?: string, providerExecuted?: boolean }\n */\n\n/**\n * Tool invocation from v4 format\n */\ntype ToolInvocation = {\n  toolCallId: string;\n  toolName: string;\n  args: Record<string, unknown>;\n  result?: unknown;\n  state: \"partial-call\" | \"call\" | \"result\" | \"error\";\n};\n\n/**\n * Legacy part from v4 format\n */\ntype LegacyPart = {\n  type: string;\n  text?: string;\n  url?: string;\n  data?: string;\n  mimeType?: string;\n  mediaType?: string;\n  filename?: string;\n};\n\n/**\n * Legacy message format from AI SDK v4\n */\nexport type LegacyMessage = {\n  id?: string;\n  role: string;\n  content: string;\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  parts?: LegacyPart[];\n  [key: string]: unknown;\n};\n\n/**\n * Corrupt content item\n */\ntype CorruptContentItem = {\n  type: string;\n  text: string;\n};\n\n/**\n * Corrupted message format - has content as array instead of parts\n */\nexport type CorruptArrayMessage = {\n  id?: string;\n  role: string;\n  content: CorruptContentItem[];\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  [key: string]: unknown;\n};\n\n/**\n * Union type for messages that could be in any format\n */\nexport type MigratableMessage = LegacyMessage | CorruptArrayMessage | UIMessage;\n\n/**\n * Tool call state mapping for v4 to v5 migration\n */\nconst STATE_MAP = {\n  \"partial-call\": \"input-streaming\",\n  call: \"input-available\",\n  result: \"output-available\",\n  error: \"output-error\"\n} as const;\n\n/**\n * Checks if a message is already in the UIMessage format (has parts array)\n */\nexport function isUIMessage(message: unknown): message is UIMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"parts\" in message &&\n    Array.isArray((message as { parts: unknown }).parts)\n  );\n}\n\n/**\n * Type guard to check if a message is in legacy format (content as string)\n */\nfunction isLegacyMessage(message: unknown): message is LegacyMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    typeof (message as { content: unknown }).content === \"string\"\n  );\n}\n\n/**\n * Type guard to check if a message has corrupted array content format\n * Detects: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n */\nfunction isCorruptArrayMessage(\n  message: unknown\n): message is CorruptArrayMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    Array.isArray((message as { content: unknown }).content) &&\n    !(\"parts\" in message) // Ensure it's not already a UIMessage\n  );\n}\n\n/**\n * Internal message part type for transformation\n */\ntype TransformMessagePart = {\n  type: string;\n  text?: string;\n  toolCallId?: string;\n  state?: string;\n  input?: Record<string, unknown>;\n  output?: unknown;\n  url?: string;\n  mediaType?: string;\n  errorText?: string;\n  filename?: string;\n};\n\n/**\n * Input message that could be in any format - using unknown for flexibility\n */\ntype InputMessage = {\n  id?: string;\n  role?: string;\n  content?: unknown;\n  reasoning?: string;\n  toolInvocations?: unknown[];\n  parts?: unknown[];\n  [key: string]: unknown;\n};\n\n/**\n * Automatic message transformer following the blog post pattern\n * Handles comprehensive migration from AI SDK v4 to v5 format\n * @param message - Message in any legacy format\n * @param index - Index for ID generation fallback\n * @returns UIMessage in v5 format\n */\nexport function autoTransformMessage(\n  message: InputMessage,\n  index = 0\n): UIMessage {\n  // Already in v5 format\n  if (isUIMessage(message)) {\n    return message;\n  }\n\n  const parts: TransformMessagePart[] = [];\n\n  // Handle reasoning transformation\n  if (message.reasoning) {\n    parts.push({\n      type: \"reasoning\",\n      text: message.reasoning\n    });\n  }\n\n  // Handle tool invocations transformation\n  if (message.toolInvocations && Array.isArray(message.toolInvocations)) {\n    message.toolInvocations.forEach((inv: unknown) => {\n      if (typeof inv === \"object\" && inv !== null && \"toolName\" in inv) {\n        const invObj = inv as ToolInvocation;\n        parts.push({\n          type: `tool-${invObj.toolName}`,\n          toolCallId: invObj.toolCallId,\n          state:\n            STATE_MAP[invObj.state as keyof typeof STATE_MAP] ||\n            \"input-available\",\n          input: invObj.args,\n          output: invObj.result !== undefined ? invObj.result : null\n        });\n      }\n    });\n  }\n\n  // Handle file parts transformation\n  if (message.parts && Array.isArray(message.parts)) {\n    message.parts.forEach((part: unknown) => {\n      if (typeof part === \"object\" && part !== null && \"type\" in part) {\n        const partObj = part as LegacyPart;\n        if (partObj.type === \"file\") {\n          parts.push({\n            type: \"file\",\n            url:\n              partObj.url ||\n              (partObj.data\n                ? `data:${partObj.mimeType || partObj.mediaType};base64,${partObj.data}`\n                : undefined),\n            mediaType: partObj.mediaType || partObj.mimeType,\n            filename: partObj.filename\n          });\n        }\n      }\n    });\n  }\n\n  // Handle corrupt array format: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n  if (Array.isArray(message.content)) {\n    message.content.forEach((item: unknown) => {\n      if (typeof item === \"object\" && item !== null && \"text\" in item) {\n        const itemObj = item as CorruptContentItem;\n        parts.push({\n          type: itemObj.type || \"text\",\n          text: itemObj.text || \"\"\n        });\n      }\n    });\n  }\n\n  // Fallback: convert plain content to text part\n  if (!parts.length && message.content !== undefined) {\n    parts.push({\n      type: \"text\",\n      text:\n        typeof message.content === \"string\"\n          ? message.content\n          : JSON.stringify(message.content)\n    });\n  }\n\n  // If still no parts, create a default text part\n  if (!parts.length) {\n    parts.push({\n      type: \"text\",\n      text: typeof message === \"string\" ? message : JSON.stringify(message)\n    });\n  }\n\n  return {\n    id: message.id || `msg-${index}`,\n    role:\n      message.role === \"data\"\n        ? \"system\"\n        : (message.role as \"user\" | \"assistant\" | \"system\") || \"user\",\n    parts: parts as UIMessage[\"parts\"]\n  };\n}\n\n/**\n * Legacy single message migration for backward compatibility\n */\nexport function migrateToUIMessage(message: MigratableMessage): UIMessage {\n  return autoTransformMessage(message as InputMessage);\n}\n\n/**\n * Automatic message transformer for arrays following the blog post pattern\n * @param messages - Array of messages in any format\n * @returns Array of UIMessages in v5 format\n */\nexport function autoTransformMessages(messages: unknown[]): UIMessage[] {\n  return messages.map((msg, i) => autoTransformMessage(msg as InputMessage, i));\n}\n\n/**\n * Migrates an array of messages to UIMessage format (legacy compatibility)\n * @param messages - Array of messages in old or new format\n * @returns Array of UIMessages in the new format\n */\nexport function migrateMessagesToUIFormat(\n  messages: MigratableMessage[]\n): UIMessage[] {\n  return autoTransformMessages(messages as InputMessage[]);\n}\n\n/**\n * Checks if any messages in an array need migration\n * @param messages - Array of messages to check\n * @returns true if any messages are not in proper UIMessage format\n */\nexport function needsMigration(messages: unknown[]): boolean {\n  return messages.some((message) => {\n    // If it's already a UIMessage, no migration needed\n    if (isUIMessage(message)) {\n      return false;\n    }\n\n    // Check for corrupt array format specifically\n    if (isCorruptArrayMessage(message)) {\n      return true;\n    }\n\n    // Check for legacy string format\n    if (isLegacyMessage(message)) {\n      return true;\n    }\n\n    // Any other format needs migration\n    return true;\n  });\n}\n\n/**\n * Analyzes the corruption types in a message array for debugging\n * @param messages - Array of messages to analyze\n * @returns Statistics about corruption types found\n */\nexport function analyzeCorruption(messages: unknown[]): {\n  total: number;\n  clean: number;\n  legacyString: number;\n  corruptArray: number;\n  unknown: number;\n  examples: {\n    legacyString?: unknown;\n    corruptArray?: unknown;\n    unknown?: unknown;\n  };\n} {\n  const stats = {\n    total: messages.length,\n    clean: 0,\n    legacyString: 0,\n    corruptArray: 0,\n    unknown: 0,\n    examples: {} as {\n      legacyString?: unknown;\n      corruptArray?: unknown;\n      unknown?: unknown;\n    }\n  };\n\n  for (const message of messages) {\n    if (isUIMessage(message)) {\n      stats.clean++;\n    } else if (isCorruptArrayMessage(message)) {\n      stats.corruptArray++;\n      if (!stats.examples.corruptArray) {\n        stats.examples.corruptArray = message;\n      }\n    } else if (isLegacyMessage(message)) {\n      stats.legacyString++;\n      if (!stats.examples.legacyString) {\n        stats.examples.legacyString = message;\n      }\n    } else {\n      stats.unknown++;\n      if (!stats.examples.unknown) {\n        stats.examples.unknown = message;\n      }\n    }\n  }\n\n  return stats;\n}\n"],"mappings":"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"}