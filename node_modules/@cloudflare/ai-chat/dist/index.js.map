{"version":3,"file":"index.js","names":["agentContext"],"sources":["../src/index.ts"],"sourcesContent":["import type {\n  UIMessage as ChatMessage,\n  DynamicToolUIPart,\n  JSONSchema7,\n  ProviderMetadata,\n  ReasoningUIPart,\n  StreamTextOnFinishCallback,\n  TextUIPart,\n  Tool,\n  ToolSet,\n  ToolUIPart,\n  UIMessageChunk\n} from \"ai\";\nimport { tool, jsonSchema } from \"ai\";\nimport {\n  Agent,\n  __DO_NOT_USE_WILL_BREAK__agentContext as agentContext,\n  type AgentContext,\n  type Connection,\n  type ConnectionContext,\n  type WSMessage\n} from \"agents\";\n\nimport {\n  MessageType,\n  type IncomingMessage,\n  type OutgoingMessage\n} from \"./types\";\nimport { autoTransformMessages } from \"./ai-chat-v5-migration\";\nimport { nanoid } from \"nanoid\";\n\n/**\n * Schema for a client-defined tool sent from the browser.\n * These tools are executed on the client, not the server.\n *\n * Note: Uses `parameters` (JSONSchema7) rather than AI SDK's `inputSchema` (FlexibleSchema)\n * because this is the wire format. Zod schemas cannot be serialized.\n *\n * @deprecated Define tools on the server using `tool()` from \"ai\" instead.\n * For tools that need client-side execution, omit the `execute` function\n * and handle them via the `onToolCall` callback in `useAgentChat`.\n */\nexport type ClientToolSchema = {\n  /** Unique name for the tool */\n  name: string;\n  /** Human-readable description of what the tool does */\n  description?: Tool[\"description\"];\n  /** JSON Schema defining the tool's input parameters */\n  parameters?: JSONSchema7;\n};\n\n/**\n * Options passed to the onChatMessage handler.\n */\nexport type OnChatMessageOptions = {\n  /** AbortSignal for cancelling the request */\n  abortSignal?: AbortSignal;\n  /**\n   * Tool schemas sent from the client for dynamic tool registration.\n   * These represent tools that will be executed on the client side.\n   * Use `createToolsFromClientSchemas()` to convert these to AI SDK tool format.\n   *\n   * @deprecated Define tools on the server instead. Use `onToolCall` callback\n   * in `useAgentChat` for client-side execution.\n   */\n  clientTools?: ClientToolSchema[];\n  /**\n   * Custom body data sent from the client via `prepareSendMessagesRequest`\n   * or the AI SDK's `body` option in `sendMessage`.\n   *\n   * Contains all fields from the request body except `messages` and `clientTools`,\n   * which are handled separately.\n   */\n  body?: Record<string, unknown>;\n};\n\n/**\n * Converts client tool schemas to AI SDK tool format.\n *\n * These tools have no `execute` function - when the AI model calls them,\n * the tool call is sent back to the client for execution.\n *\n * @param clientTools - Array of tool schemas from the client\n * @returns Record of AI SDK tools that can be spread into your tools object\n *\n * @deprecated Define tools on the server using `tool()` from \"ai\" instead.\n * For tools that need client-side execution, omit the `execute` function\n * and handle them via the `onToolCall` callback in `useAgentChat`.\n *\n * @example\n * ```typescript\n * // Server: Define tool without execute\n * const tools = {\n *   getLocation: tool({\n *     description: \"Get user's location\",\n *     inputSchema: z.object({})\n *     // No execute = client must handle\n *   })\n * };\n *\n * // Client: Handle in onToolCall\n * useAgentChat({\n *   onToolCall: async ({ toolCall, addToolOutput }) => {\n *     if (toolCall.toolName === 'getLocation') {\n *       const pos = await navigator.geolocation.getCurrentPosition();\n *       addToolOutput({ toolCallId: toolCall.toolCallId, output: pos });\n *     }\n *   }\n * });\n * ```\n */\nexport function createToolsFromClientSchemas(\n  clientTools?: ClientToolSchema[]\n): ToolSet {\n  if (!clientTools || clientTools.length === 0) {\n    return {};\n  }\n\n  // Check for duplicate tool names\n  const seenNames = new Set<string>();\n  for (const t of clientTools) {\n    if (seenNames.has(t.name)) {\n      console.warn(\n        `[createToolsFromClientSchemas] Duplicate tool name \"${t.name}\" found. Later definitions will override earlier ones.`\n      );\n    }\n    seenNames.add(t.name);\n  }\n\n  return Object.fromEntries(\n    clientTools.map((t) => [\n      t.name,\n      tool({\n        description: t.description ?? \"\",\n        inputSchema: jsonSchema(t.parameters ?? { type: \"object\" })\n        // No execute function = tool call is sent back to client\n      })\n    ])\n  );\n}\n\n/** Number of chunks to buffer before flushing to SQLite */\nconst CHUNK_BUFFER_SIZE = 10;\n/** Maximum buffer size to prevent memory issues on rapid reconnections */\nconst CHUNK_BUFFER_MAX_SIZE = 100;\n/** Maximum age for a \"streaming\" stream before considering it stale (ms) - 5 minutes */\nconst STREAM_STALE_THRESHOLD_MS = 5 * 60 * 1000;\n/** Default cleanup interval for old streams (ms) - every 10 minutes */\nconst CLEANUP_INTERVAL_MS = 10 * 60 * 1000;\n/** Default age threshold for cleaning up completed streams (ms) - 24 hours */\nconst CLEANUP_AGE_THRESHOLD_MS = 24 * 60 * 60 * 1000;\n\nconst decoder = new TextDecoder();\n\n/**\n * Stored stream chunk for resumable streaming\n */\ntype StreamChunk = {\n  id: string;\n  stream_id: string;\n  body: string;\n  chunk_index: number;\n  created_at: number;\n};\n\n/**\n * Stream metadata for tracking active streams\n */\ntype StreamMetadata = {\n  id: string;\n  request_id: string;\n  status: \"streaming\" | \"completed\" | \"error\";\n  created_at: number;\n  completed_at: number | null;\n};\n\n/**\n * Extension of Agent with built-in chat capabilities\n * @template Env Environment type containing bindings\n */\nexport class AIChatAgent<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  State = unknown\n> extends Agent<Env, State> {\n  /**\n   * Map of message `id`s to `AbortController`s\n   * useful to propagate request cancellation signals for any external calls made by the agent\n   */\n  private _chatMessageAbortControllers: Map<string, AbortController>;\n\n  /**\n   * Currently active stream ID for resumable streaming.\n   * Stored in memory for quick access; persisted in stream_metadata table.\n   * @internal Protected for testing purposes.\n   */\n  protected _activeStreamId: string | null = null;\n\n  /**\n   * Request ID associated with the active stream.\n   * @internal Protected for testing purposes.\n   */\n  protected _activeRequestId: string | null = null;\n\n  /**\n   * The message currently being streamed. Used to apply tool results\n   * before the message is persisted.\n   * @internal\n   */\n  private _streamingMessage: ChatMessage | null = null;\n\n  /**\n   * Promise that resolves when the current stream completes.\n   * Used to wait for message persistence before continuing after tool results.\n   * @internal\n   */\n  private _streamCompletionPromise: Promise<void> | null = null;\n  private _streamCompletionResolve: (() => void) | null = null;\n\n  /**\n   * Current chunk index for the active stream\n   */\n  private _streamChunkIndex = 0;\n\n  /**\n   * Buffer for stream chunks pending write to SQLite.\n   * Chunks are batched and flushed when buffer reaches CHUNK_BUFFER_SIZE.\n   */\n  private _chunkBuffer: Array<{\n    id: string;\n    streamId: string;\n    body: string;\n    index: number;\n  }> = [];\n\n  /**\n   * Lock to prevent concurrent flush operations\n   */\n  private _isFlushingChunks = false;\n\n  /**\n   * Timestamp of the last cleanup operation for old streams\n   */\n  private _lastCleanupTime = 0;\n\n  /**\n   * Set of connection IDs that are pending stream resume.\n   * These connections have received CF_AGENT_STREAM_RESUMING but haven't sent ACK yet.\n   * They should be excluded from live stream broadcasts until they ACK.\n   * @internal\n   */\n  private _pendingResumeConnections: Set<string> = new Set();\n\n  /**\n   * Client tool schemas from the most recent chat request.\n   * Stored so they can be passed to onChatMessage during tool continuations.\n   * @internal\n   */\n  private _lastClientTools: ClientToolSchema[] | undefined;\n\n  /** Array of chat messages for the current conversation */\n  messages: ChatMessage[];\n\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n    this.sql`create table if not exists cf_ai_chat_agent_messages (\n      id text primary key,\n      message text not null,\n      created_at datetime default current_timestamp\n    )`;\n\n    // Create tables for automatic resumable streaming\n    this.sql`create table if not exists cf_ai_chat_stream_chunks (\n      id text primary key,\n      stream_id text not null,\n      body text not null,\n      chunk_index integer not null,\n      created_at integer not null\n    )`;\n\n    this.sql`create table if not exists cf_ai_chat_stream_metadata (\n      id text primary key,\n      request_id text not null,\n      status text not null,\n      created_at integer not null,\n      completed_at integer\n    )`;\n\n    this.sql`create index if not exists idx_stream_chunks_stream_id \n      on cf_ai_chat_stream_chunks(stream_id, chunk_index)`;\n\n    // Load messages and automatically transform them to v5 format\n    const rawMessages = this._loadMessagesFromDb();\n\n    // Automatic migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n    this.messages = autoTransformMessages(rawMessages);\n\n    this._chatMessageAbortControllers = new Map();\n\n    // Check for any active streams from a previous session\n    this._restoreActiveStream();\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = async (connection: Connection, ctx: ConnectionContext) => {\n      // Notify client about active streams that can be resumed\n      if (this._activeStreamId) {\n        this._notifyStreamResuming(connection);\n      }\n      // Call consumer's onConnect\n      return _onConnect(connection, ctx);\n    };\n\n    // Wrap onClose to clean up pending resume connections\n    const _onClose = this.onClose.bind(this);\n    this.onClose = async (\n      connection: Connection,\n      code: number,\n      reason: string,\n      wasClean: boolean\n    ) => {\n      // Clean up pending resume state for this connection\n      this._pendingResumeConnections.delete(connection.id);\n      // Call consumer's onClose\n      return _onClose(connection, code, reason, wasClean);\n    };\n\n    // Wrap onMessage\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      // Handle AIChatAgent's internal messages first\n      if (typeof message === \"string\") {\n        let data: IncomingMessage;\n        try {\n          data = JSON.parse(message) as IncomingMessage;\n        } catch (_error) {\n          // Not JSON, forward to consumer\n          return _onMessage(connection, message);\n        }\n\n        // Handle chat request\n        if (\n          data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST &&\n          data.init.method === \"POST\"\n        ) {\n          const { body } = data.init;\n          const parsed = JSON.parse(body as string);\n          const { messages, clientTools, ...customBody } = parsed as {\n            messages: ChatMessage[];\n            clientTools?: ClientToolSchema[];\n            [key: string]: unknown;\n          };\n\n          // Store client tools for use during tool continuations\n          this._lastClientTools = clientTools?.length ? clientTools : undefined;\n\n          // Automatically transform any incoming messages\n          const transformedMessages = autoTransformMessages(messages);\n\n          this._broadcastChatMessage(\n            {\n              messages: transformedMessages,\n              type: MessageType.CF_AGENT_CHAT_MESSAGES\n            },\n            [connection.id]\n          );\n\n          await this.persistMessages(transformedMessages, [connection.id]);\n\n          this.observability?.emit(\n            {\n              displayMessage: \"Chat message request\",\n              id: data.id,\n              payload: {},\n              timestamp: Date.now(),\n              type: \"message:request\"\n            },\n            this.ctx\n          );\n\n          const chatMessageId = data.id;\n          const abortSignal = this._getAbortSignal(chatMessageId);\n\n          return this._tryCatchChat(async () => {\n            // Wrap in agentContext.run() to propagate connection context to onChatMessage\n            // This ensures getCurrentAgent() returns the connection inside tool execute functions\n            return agentContext.run(\n              { agent: this, connection, request: undefined, email: undefined },\n              async () => {\n                const response = await this.onChatMessage(\n                  async (_finishResult) => {\n                    this._removeAbortController(chatMessageId);\n\n                    this.observability?.emit(\n                      {\n                        displayMessage: \"Chat message response\",\n                        id: data.id,\n                        payload: {},\n                        timestamp: Date.now(),\n                        type: \"message:response\"\n                      },\n                      this.ctx\n                    );\n                  },\n                  {\n                    abortSignal,\n                    clientTools,\n                    body:\n                      Object.keys(customBody).length > 0\n                        ? customBody\n                        : undefined\n                  }\n                );\n\n                if (response) {\n                  await this._reply(data.id, response, [connection.id]);\n                } else {\n                  console.warn(\n                    `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`\n                  );\n                  this._broadcastChatMessage(\n                    {\n                      body: \"No response was generated by the agent.\",\n                      done: true,\n                      id: data.id,\n                      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                    },\n                    [connection.id]\n                  );\n                }\n              }\n            );\n          });\n        }\n\n        // Handle clear chat\n        if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {\n          this._destroyAbortControllers();\n          this.sql`delete from cf_ai_chat_agent_messages`;\n          this.sql`delete from cf_ai_chat_stream_chunks`;\n          this.sql`delete from cf_ai_chat_stream_metadata`;\n          this._activeStreamId = null;\n          this._activeRequestId = null;\n          this._streamChunkIndex = 0;\n          this._pendingResumeConnections.clear();\n          this._lastClientTools = undefined;\n          this.messages = [];\n          this._broadcastChatMessage(\n            { type: MessageType.CF_AGENT_CHAT_CLEAR },\n            [connection.id]\n          );\n          return;\n        }\n\n        // Handle message replacement\n        if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {\n          const transformedMessages = autoTransformMessages(data.messages);\n          await this.persistMessages(transformedMessages, [connection.id]);\n          return;\n        }\n\n        // Handle request cancellation\n        if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) {\n          this._cancelChatRequest(data.id);\n          return;\n        }\n\n        // Handle stream resume acknowledgment\n        if (data.type === MessageType.CF_AGENT_STREAM_RESUME_ACK) {\n          this._pendingResumeConnections.delete(connection.id);\n\n          if (\n            this._activeStreamId &&\n            this._activeRequestId &&\n            this._activeRequestId === data.id\n          ) {\n            this._sendStreamChunks(\n              connection,\n              this._activeStreamId,\n              this._activeRequestId\n            );\n          }\n          return;\n        }\n\n        // Handle client-side tool result\n        if (data.type === MessageType.CF_AGENT_TOOL_RESULT) {\n          const { toolCallId, toolName, output, autoContinue } = data;\n\n          // Apply the tool result\n          this._applyToolResult(toolCallId, toolName, output).then(\n            (applied) => {\n              // Only auto-continue if client requested it (opt-in behavior)\n              // This mimics server-executed tool behavior where the LLM\n              // automatically continues after seeing tool results\n              if (applied && autoContinue) {\n                // Wait for the original stream to complete and message to be persisted\n                // before calling onChatMessage, so this.messages includes the tool result\n                const waitForStream = async () => {\n                  if (this._streamCompletionPromise) {\n                    await this._streamCompletionPromise;\n                  } else {\n                    // If no promise, wait a bit for the stream to finish\n                    await new Promise((resolve) => setTimeout(resolve, 500));\n                  }\n                };\n\n                waitForStream().then(() => {\n                  const continuationId = nanoid();\n                  const abortSignal = this._getAbortSignal(continuationId);\n\n                  this._tryCatchChat(async () => {\n                    return agentContext.run(\n                      {\n                        agent: this,\n                        connection,\n                        request: undefined,\n                        email: undefined\n                      },\n                      async () => {\n                        const response = await this.onChatMessage(\n                          async (_finishResult) => {\n                            this._removeAbortController(continuationId);\n\n                            this.observability?.emit(\n                              {\n                                displayMessage:\n                                  \"Chat message response (tool continuation)\",\n                                id: continuationId,\n                                payload: {},\n                                timestamp: Date.now(),\n                                type: \"message:response\"\n                              },\n                              this.ctx\n                            );\n                          },\n                          {\n                            abortSignal,\n                            clientTools: this._lastClientTools\n                          }\n                        );\n\n                        if (response) {\n                          // Pass continuation flag to merge parts into last assistant message\n                          // Note: We pass an empty excludeBroadcastIds array because the sender\n                          // NEEDS to receive the continuation stream. Unlike regular chat requests\n                          // where aiFetch handles the response, tool continuations have no listener\n                          // waiting - the client relies on the broadcast.\n                          await this._reply(\n                            continuationId,\n                            response,\n                            [], // Don't exclude sender - they need the continuation\n                            { continuation: true }\n                          );\n                        }\n                      }\n                    );\n                  });\n                });\n              }\n            }\n          );\n          return;\n        }\n\n        // Handle client-side tool approval response\n        if (data.type === MessageType.CF_AGENT_TOOL_APPROVAL) {\n          const { toolCallId, approved } = data;\n          this._applyToolApproval(toolCallId, approved);\n          return;\n        }\n      }\n\n      // Forward unhandled messages to consumer's onMessage\n      return _onMessage(connection, message);\n    };\n  }\n\n  /**\n   * Restore active stream state if the agent was restarted during streaming.\n   * Called during construction to recover any interrupted streams.\n   * Validates stream freshness to avoid sending stale resume notifications.\n   * @internal Protected for testing purposes.\n   */\n  protected _restoreActiveStream() {\n    const activeStreams = this.sql<StreamMetadata>`\n      select * from cf_ai_chat_stream_metadata \n      where status = 'streaming' \n      order by created_at desc \n      limit 1\n    `;\n\n    if (activeStreams && activeStreams.length > 0) {\n      const stream = activeStreams[0];\n      const streamAge = Date.now() - stream.created_at;\n\n      // Check if stream is stale; delete to free storage\n      if (streamAge > STREAM_STALE_THRESHOLD_MS) {\n        this\n          .sql`delete from cf_ai_chat_stream_chunks where stream_id = ${stream.id}`;\n        this\n          .sql`delete from cf_ai_chat_stream_metadata where id = ${stream.id}`;\n        console.warn(\n          `[AIChatAgent] Deleted stale stream ${stream.id} (age: ${Math.round(streamAge / 1000)}s)`\n        );\n        return;\n      }\n\n      this._activeStreamId = stream.id;\n      this._activeRequestId = stream.request_id;\n\n      // Get the last chunk index\n      const lastChunk = this.sql<{ max_index: number }>`\n        select max(chunk_index) as max_index \n        from cf_ai_chat_stream_chunks \n        where stream_id = ${this._activeStreamId}\n      `;\n      this._streamChunkIndex =\n        lastChunk && lastChunk[0]?.max_index != null\n          ? lastChunk[0].max_index + 1\n          : 0;\n    }\n  }\n\n  /**\n   * Notify a connection about an active stream that can be resumed.\n   * The client should respond with CF_AGENT_STREAM_RESUME_ACK to receive chunks.\n   * Uses in-memory state for request ID - no extra DB lookup needed.\n   * @param connection - The WebSocket connection to notify\n   */\n  private _notifyStreamResuming(connection: Connection) {\n    if (!this._activeStreamId || !this._activeRequestId) {\n      return;\n    }\n\n    // Add connection to pending set - they'll be excluded from live broadcasts\n    // until they send ACK to receive the full stream replay\n    this._pendingResumeConnections.add(connection.id);\n\n    // Notify client - they will send ACK when ready\n    connection.send(\n      JSON.stringify({\n        type: MessageType.CF_AGENT_STREAM_RESUMING,\n        id: this._activeRequestId\n      })\n    );\n  }\n\n  /**\n   * Send stream chunks to a connection after receiving ACK.\n   * @param connection - The WebSocket connection\n   * @param streamId - The stream to replay\n   * @param requestId - The original request ID\n   */\n  private _sendStreamChunks(\n    connection: Connection,\n    streamId: string,\n    requestId: string\n  ) {\n    // Flush any pending chunks first to ensure we have the latest\n    this._flushChunkBuffer();\n\n    const chunks = this.sql<StreamChunk>`\n      select * from cf_ai_chat_stream_chunks \n      where stream_id = ${streamId} \n      order by chunk_index asc\n    `;\n\n    // Send all stored chunks\n    for (const chunk of chunks || []) {\n      connection.send(\n        JSON.stringify({\n          body: chunk.body,\n          done: false,\n          id: requestId,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        })\n      );\n    }\n\n    // If the stream is no longer active (completed), send done signal\n    // We track active state in memory, no need to query DB\n    if (this._activeStreamId !== streamId) {\n      connection.send(\n        JSON.stringify({\n          body: \"\",\n          done: true,\n          id: requestId,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        })\n      );\n    }\n  }\n\n  /**\n   * Buffer a stream chunk for batch write to SQLite.\n   * @param streamId - The stream this chunk belongs to\n   * @param body - The serialized chunk body\n   * @internal Protected for testing purposes.\n   */\n  protected _storeStreamChunk(streamId: string, body: string) {\n    // Force flush if buffer is at max to prevent memory issues\n    if (this._chunkBuffer.length >= CHUNK_BUFFER_MAX_SIZE) {\n      this._flushChunkBuffer();\n    }\n\n    this._chunkBuffer.push({\n      id: nanoid(),\n      streamId,\n      body,\n      index: this._streamChunkIndex\n    });\n    this._streamChunkIndex++;\n\n    // Flush when buffer reaches threshold\n    if (this._chunkBuffer.length >= CHUNK_BUFFER_SIZE) {\n      this._flushChunkBuffer();\n    }\n  }\n\n  /**\n   * Flush buffered chunks to SQLite in a single batch.\n   * Uses a lock to prevent concurrent flush operations.\n   * @internal Protected for testing purposes.\n   */\n  protected _flushChunkBuffer() {\n    // Prevent concurrent flushes\n    if (this._isFlushingChunks || this._chunkBuffer.length === 0) {\n      return;\n    }\n\n    this._isFlushingChunks = true;\n    try {\n      const chunks = this._chunkBuffer;\n      this._chunkBuffer = [];\n\n      // Batch insert all chunks\n      const now = Date.now();\n      for (const chunk of chunks) {\n        this.sql`\n          insert into cf_ai_chat_stream_chunks (id, stream_id, body, chunk_index, created_at)\n          values (${chunk.id}, ${chunk.streamId}, ${chunk.body}, ${chunk.index}, ${now})\n        `;\n      }\n    } finally {\n      this._isFlushingChunks = false;\n    }\n  }\n\n  /**\n   * Start tracking a new stream for resumable streaming.\n   * Creates metadata entry in SQLite and sets up tracking state.\n   * @param requestId - The unique ID of the chat request\n   * @returns The generated stream ID\n   * @internal Protected for testing purposes.\n   */\n  protected _startStream(requestId: string): string {\n    // Flush any pending chunks from previous streams to prevent mixing\n    this._flushChunkBuffer();\n\n    const streamId = nanoid();\n    this._activeStreamId = streamId;\n    this._activeRequestId = requestId;\n    this._streamChunkIndex = 0;\n\n    this.sql`\n      insert into cf_ai_chat_stream_metadata (id, request_id, status, created_at)\n      values (${streamId}, ${requestId}, 'streaming', ${Date.now()})\n    `;\n\n    return streamId;\n  }\n\n  /**\n   * Mark a stream as completed and flush any pending chunks.\n   * @param streamId - The stream to mark as completed\n   * @internal Protected for testing purposes.\n   */\n  protected _completeStream(streamId: string) {\n    // Flush any pending chunks before completing\n    this._flushChunkBuffer();\n\n    this.sql`\n      update cf_ai_chat_stream_metadata \n      set status = 'completed', completed_at = ${Date.now()} \n      where id = ${streamId}\n    `;\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n    this._streamChunkIndex = 0;\n\n    // Clear pending resume connections - no active stream to resume\n    this._pendingResumeConnections.clear();\n\n    // Periodically clean up old streams (not on every completion)\n    this._maybeCleanupOldStreams();\n  }\n\n  /**\n   * Clean up old completed streams if enough time has passed since last cleanup.\n   * This prevents database growth while avoiding cleanup overhead on every stream completion.\n   */\n  private _maybeCleanupOldStreams() {\n    const now = Date.now();\n    if (now - this._lastCleanupTime < CLEANUP_INTERVAL_MS) {\n      return;\n    }\n    this._lastCleanupTime = now;\n\n    const cutoff = now - CLEANUP_AGE_THRESHOLD_MS;\n    this.sql`\n      delete from cf_ai_chat_stream_chunks \n      where stream_id in (\n        select id from cf_ai_chat_stream_metadata \n        where status = 'completed' and completed_at < ${cutoff}\n      )\n    `;\n    this.sql`\n      delete from cf_ai_chat_stream_metadata \n      where status = 'completed' and completed_at < ${cutoff}\n    `;\n  }\n\n  private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {\n    // Combine explicit exclusions with connections pending stream resume.\n    // Pending connections should not receive live stream chunks until they ACK,\n    // at which point they'll receive the full replay via _sendStreamChunks.\n    const allExclusions = [\n      ...(exclude || []),\n      ...this._pendingResumeConnections\n    ];\n    this.broadcast(JSON.stringify(message), allExclusions);\n  }\n\n  /**\n   * Broadcasts a text event for non-SSE responses.\n   * This ensures plain text responses follow the AI SDK v5 stream protocol.\n   *\n   * @param streamId - The stream identifier for chunk storage\n   * @param event - The text event payload (text-start, text-delta with delta, or text-end)\n   * @param continuation - Whether this is a continuation of a previous stream\n   */\n  private _broadcastTextEvent(\n    streamId: string,\n    event:\n      | { type: \"text-start\"; id: string }\n      | { type: \"text-delta\"; id: string; delta: string }\n      | { type: \"text-end\"; id: string },\n    continuation: boolean\n  ) {\n    const body = JSON.stringify(event);\n    this._storeStreamChunk(streamId, body);\n    this._broadcastChatMessage({\n      body,\n      done: false,\n      id: event.id,\n      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n      ...(continuation && { continuation: true })\n    });\n  }\n\n  private _loadMessagesFromDb(): ChatMessage[] {\n    const rows =\n      this.sql`select * from cf_ai_chat_agent_messages order by created_at` ||\n      [];\n    return rows\n      .map((row) => {\n        try {\n          return JSON.parse(row.message as string);\n        } catch (error) {\n          console.error(`Failed to parse message ${row.id}:`, error);\n          return null;\n        }\n      })\n      .filter((msg): msg is ChatMessage => msg !== null);\n  }\n\n  override async onRequest(request: Request): Promise<Response> {\n    return this._tryCatchChat(async () => {\n      const url = new URL(request.url);\n\n      if (url.pathname.endsWith(\"/get-messages\")) {\n        const messages = this._loadMessagesFromDb();\n        return Response.json(messages);\n      }\n\n      return super.onRequest(request);\n    });\n  }\n\n  private async _tryCatchChat<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Handle incoming chat messages and generate a response\n   * @param onFinish Callback to be called when the response is finished\n   * @param options Options including abort signal and client-defined tools\n   * @returns Response to send to the client or undefined\n   */\n  async onChatMessage(\n    // oxlint-disable-next-line eslint(no-unused-vars) -- params used by subclass overrides\n    onFinish: StreamTextOnFinishCallback<ToolSet>,\n    // oxlint-disable-next-line eslint(no-unused-vars) -- params used by subclass overrides\n    options?: OnChatMessageOptions\n  ): Promise<Response | undefined> {\n    throw new Error(\n      \"recieved a chat message, override onChatMessage and return a Response to send to the client\"\n    );\n  }\n\n  /**\n   * Save messages on the server side\n   * @param messages Chat messages to save\n   */\n  async saveMessages(messages: ChatMessage[]) {\n    await this.persistMessages(messages);\n    await this._tryCatchChat(async () => {\n      const response = await this.onChatMessage(() => {});\n      if (response) this._reply(crypto.randomUUID(), response);\n    });\n  }\n\n  async persistMessages(\n    messages: ChatMessage[],\n    excludeBroadcastIds: string[] = []\n  ) {\n    // Merge incoming messages with existing server state to preserve tool outputs.\n    // This is critical for client-side tools: the client sends messages without\n    // tool outputs, but the server has them via _applyToolResult.\n    const mergedMessages = this._mergeIncomingWithServerState(messages);\n\n    // Persist the merged messages\n    for (const message of mergedMessages) {\n      // Strip OpenAI item IDs to prevent \"Duplicate item found\" errors\n      // when using the OpenAI Responses API. These IDs are assigned by OpenAI\n      // and if sent back in subsequent requests, cause duplicate detection.\n      const sanitizedMessage = this._sanitizeMessageForPersistence(message);\n      const messageToSave = this._resolveMessageForToolMerge(sanitizedMessage);\n      this.sql`\n        insert into cf_ai_chat_agent_messages (id, message)\n        values (${messageToSave.id}, ${JSON.stringify(messageToSave)})\n        on conflict(id) do update set message = excluded.message\n      `;\n    }\n\n    // refresh in-memory messages\n    const persisted = this._loadMessagesFromDb();\n    this.messages = autoTransformMessages(persisted);\n    this._broadcastChatMessage(\n      {\n        messages: mergedMessages,\n        type: MessageType.CF_AGENT_CHAT_MESSAGES\n      },\n      excludeBroadcastIds\n    );\n  }\n\n  /**\n   * Merges incoming messages with existing server state.\n   * This preserves tool outputs that the server has (via _applyToolResult)\n   * but the client doesn't have yet.\n   *\n   * @param incomingMessages - Messages from the client\n   * @returns Messages with server's tool outputs preserved\n   */\n  private _mergeIncomingWithServerState(\n    incomingMessages: ChatMessage[]\n  ): ChatMessage[] {\n    // Build a map of toolCallId -> output from existing server messages\n    const serverToolOutputs = new Map<string, unknown>();\n    for (const msg of this.messages) {\n      if (msg.role !== \"assistant\") continue;\n      for (const part of msg.parts) {\n        if (\n          \"toolCallId\" in part &&\n          \"state\" in part &&\n          part.state === \"output-available\" &&\n          \"output\" in part\n        ) {\n          serverToolOutputs.set(\n            part.toolCallId as string,\n            (part as { output: unknown }).output\n          );\n        }\n      }\n    }\n\n    // If server has no tool outputs, return incoming messages as-is\n    if (serverToolOutputs.size === 0) {\n      return incomingMessages;\n    }\n\n    // Merge server's tool outputs into incoming messages\n    return incomingMessages.map((msg) => {\n      if (msg.role !== \"assistant\") return msg;\n\n      let hasChanges = false;\n      const updatedParts = msg.parts.map((part) => {\n        // If this is a tool part in input-available state and server has the output\n        if (\n          \"toolCallId\" in part &&\n          \"state\" in part &&\n          part.state === \"input-available\" &&\n          serverToolOutputs.has(part.toolCallId as string)\n        ) {\n          hasChanges = true;\n          return {\n            ...part,\n            state: \"output-available\" as const,\n            output: serverToolOutputs.get(part.toolCallId as string)\n          };\n        }\n        return part;\n      }) as ChatMessage[\"parts\"];\n\n      return hasChanges ? { ...msg, parts: updatedParts } : msg;\n    });\n  }\n\n  /**\n   * Resolves a message for persistence, handling tool result merging.\n   * If the message contains tool parts with output-available state, checks if there's\n   * an existing message with the same toolCallId that should be updated instead of\n   * creating a duplicate. This prevents the \"Duplicate item found\" error from OpenAI\n   * when client-side tool results arrive in a new request.\n   *\n   * @param message - The message to potentially merge\n   * @returns The message with the correct ID (either original or merged)\n   */\n  private _resolveMessageForToolMerge(message: ChatMessage): ChatMessage {\n    if (message.role !== \"assistant\") {\n      return message;\n    }\n\n    // Check if this message has tool parts with output-available state\n    for (const part of message.parts) {\n      if (\n        \"toolCallId\" in part &&\n        \"state\" in part &&\n        (part.state === \"output-available\" ||\n          part.state === \"approval-responded\" ||\n          part.state === \"approval-requested\")\n      ) {\n        const toolCallId = part.toolCallId as string;\n\n        // Look for an existing message with this toolCallId in input-available state\n        const existingMessage = this._findMessageByToolCallId(toolCallId);\n        if (existingMessage && existingMessage.id !== message.id) {\n          // Found a match - merge by using the existing message's ID\n          // This ensures the SQL upsert updates the existing row\n          return {\n            ...message,\n            id: existingMessage.id\n          };\n        }\n      }\n    }\n\n    return message;\n  }\n\n  /**\n   * Finds an existing assistant message that contains a tool part with the given toolCallId.\n   * Used to detect when a tool result should update an existing message rather than\n   * creating a new one.\n   *\n   * @param toolCallId - The tool call ID to search for\n   * @returns The existing message if found, undefined otherwise\n   */\n  private _findMessageByToolCallId(\n    toolCallId: string\n  ): ChatMessage | undefined {\n    for (const msg of this.messages) {\n      if (msg.role !== \"assistant\") continue;\n\n      for (const part of msg.parts) {\n        if (\"toolCallId\" in part && part.toolCallId === toolCallId) {\n          return msg;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Sanitizes a message for persistence by removing ephemeral provider-specific\n   * data that should not be stored or sent back in subsequent requests.\n   *\n   * This handles two issues with the OpenAI Responses API:\n   *\n   * 1. **Duplicate item IDs**: The AI SDK's @ai-sdk/openai provider (v2.0.x+)\n   *    defaults to using OpenAI's Responses API which assigns unique itemIds\n   *    to each message part. When these IDs are persisted and sent back,\n   *    OpenAI rejects them as duplicates.\n   *\n   * 2. **Empty reasoning parts**: OpenAI may return reasoning parts with empty\n   *    text and encrypted content. These cause \"Non-OpenAI reasoning parts are\n   *    not supported\" warnings when sent back via convertToModelMessages().\n   *\n   * @param message - The message to sanitize\n   * @returns A new message with ephemeral provider data removed\n   */\n  private _sanitizeMessageForPersistence(message: ChatMessage): ChatMessage {\n    // First, filter out empty reasoning parts (they have no useful content)\n    const filteredParts = message.parts.filter((part) => {\n      if (part.type === \"reasoning\") {\n        const reasoningPart = part as ReasoningUIPart;\n        // Remove reasoning parts that have no text content\n        // These are typically placeholders with only encrypted content\n        if (!reasoningPart.text || reasoningPart.text.trim() === \"\") {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    // Then sanitize remaining parts by stripping OpenAI-specific ephemeral data\n    const sanitizedParts = filteredParts.map((part) => {\n      let sanitizedPart = part;\n\n      // Strip providerMetadata.openai.itemId and reasoningEncryptedContent\n      if (\n        \"providerMetadata\" in sanitizedPart &&\n        sanitizedPart.providerMetadata &&\n        typeof sanitizedPart.providerMetadata === \"object\" &&\n        \"openai\" in sanitizedPart.providerMetadata\n      ) {\n        sanitizedPart = this._stripOpenAIMetadata(\n          sanitizedPart,\n          \"providerMetadata\"\n        );\n      }\n\n      // Also check callProviderMetadata for tool parts\n      if (\n        \"callProviderMetadata\" in sanitizedPart &&\n        sanitizedPart.callProviderMetadata &&\n        typeof sanitizedPart.callProviderMetadata === \"object\" &&\n        \"openai\" in sanitizedPart.callProviderMetadata\n      ) {\n        sanitizedPart = this._stripOpenAIMetadata(\n          sanitizedPart,\n          \"callProviderMetadata\"\n        );\n      }\n\n      return sanitizedPart;\n    }) as ChatMessage[\"parts\"];\n\n    return { ...message, parts: sanitizedParts };\n  }\n\n  /**\n   * Helper to strip OpenAI-specific ephemeral fields from a metadata object.\n   * Removes itemId and reasoningEncryptedContent while preserving other fields.\n   */\n  private _stripOpenAIMetadata<T extends ChatMessage[\"parts\"][number]>(\n    part: T,\n    metadataKey: \"providerMetadata\" | \"callProviderMetadata\"\n  ): T {\n    const metadata = (part as Record<string, unknown>)[metadataKey] as {\n      openai?: Record<string, unknown>;\n      [key: string]: unknown;\n    };\n\n    if (!metadata?.openai) return part;\n\n    const openaiMeta = metadata.openai;\n\n    // Remove ephemeral fields: itemId and reasoningEncryptedContent\n    const {\n      itemId: _itemId,\n      reasoningEncryptedContent: _rec,\n      ...restOpenai\n    } = openaiMeta;\n\n    // Determine what to keep\n    const hasOtherOpenaiFields = Object.keys(restOpenai).length > 0;\n    const { openai: _openai, ...restMetadata } = metadata;\n\n    let newMetadata: ProviderMetadata | undefined;\n    if (hasOtherOpenaiFields) {\n      newMetadata = {\n        ...restMetadata,\n        openai: restOpenai\n      } as ProviderMetadata;\n    } else if (Object.keys(restMetadata).length > 0) {\n      newMetadata = restMetadata as ProviderMetadata;\n    }\n\n    // Create new part without the old metadata\n    const { [metadataKey]: _oldMeta, ...restPart } = part as Record<\n      string,\n      unknown\n    >;\n\n    if (newMetadata) {\n      return { ...restPart, [metadataKey]: newMetadata } as T;\n    }\n    return restPart as T;\n  }\n\n  /**\n   * Applies a tool result to an existing assistant message.\n   * This is used when the client sends CF_AGENT_TOOL_RESULT for client-side tools.\n   * The server is the source of truth, so we update the message here and broadcast\n   * the update to all clients.\n   *\n   * @param toolCallId - The tool call ID this result is for\n   * @param toolName - The name of the tool\n   * @param output - The output from the tool execution\n   * @returns true if the result was applied, false if the message was not found\n   */\n  private async _applyToolResult(\n    toolCallId: string,\n    _toolName: string,\n    output: unknown\n  ): Promise<boolean> {\n    // Find the message with this tool call\n    // First check the currently streaming message\n    let message: ChatMessage | undefined;\n\n    // Check streaming message first\n    if (this._streamingMessage) {\n      for (const part of this._streamingMessage.parts) {\n        if (\"toolCallId\" in part && part.toolCallId === toolCallId) {\n          message = this._streamingMessage;\n          break;\n        }\n      }\n    }\n\n    // If not found in streaming message, retry persisted messages\n    if (!message) {\n      for (let attempt = 0; attempt < 10; attempt++) {\n        message = this._findMessageByToolCallId(toolCallId);\n        if (message) break;\n        // Wait 100ms before retrying\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n\n    if (!message) {\n      // The tool result will be included when\n      // the client sends the follow-up message via sendMessage().\n      console.warn(\n        `[AIChatAgent] _applyToolResult: Could not find message with toolCallId ${toolCallId} after retries`\n      );\n      return false;\n    }\n\n    // Check if this is the streaming message (not yet persisted)\n    const isStreamingMessage = message === this._streamingMessage;\n\n    // Update the tool part with the output\n    let updated = false;\n    if (isStreamingMessage) {\n      // Update in place - the message will be persisted when streaming completes\n      for (const part of message.parts) {\n        if (\n          \"toolCallId\" in part &&\n          part.toolCallId === toolCallId &&\n          \"state\" in part &&\n          part.state === \"input-available\"\n        ) {\n          (part as { state: string; output?: unknown }).state =\n            \"output-available\";\n          (part as { state: string; output?: unknown }).output = output;\n          updated = true;\n          break;\n        }\n      }\n    } else {\n      // For persisted messages, create updated parts\n      const updatedParts = message.parts.map((part) => {\n        if (\n          \"toolCallId\" in part &&\n          part.toolCallId === toolCallId &&\n          \"state\" in part &&\n          part.state === \"input-available\"\n        ) {\n          updated = true;\n          return {\n            ...part,\n            state: \"output-available\" as const,\n            output\n          };\n        }\n        return part;\n      }) as ChatMessage[\"parts\"];\n\n      if (updated) {\n        // Create the updated message and strip OpenAI item IDs\n        const updatedMessage: ChatMessage = this._sanitizeMessageForPersistence(\n          {\n            ...message,\n            parts: updatedParts\n          }\n        );\n\n        // Persist the updated message\n        this.sql`\n          update cf_ai_chat_agent_messages \n          set message = ${JSON.stringify(updatedMessage)}\n          where id = ${message.id}\n        `;\n\n        // Reload messages to update in-memory state\n        const persisted = this._loadMessagesFromDb();\n        this.messages = autoTransformMessages(persisted);\n      }\n    }\n\n    if (!updated) {\n      console.warn(\n        `[AIChatAgent] _applyToolResult: Tool part with toolCallId ${toolCallId} not in input-available state`\n      );\n      return false;\n    }\n\n    // Broadcast the update to all clients (only for persisted messages)\n    // For streaming messages, the update will be included when persisted\n    if (!isStreamingMessage) {\n      // Re-fetch the message for broadcast since we modified it\n      const broadcastMessage = this._findMessageByToolCallId(toolCallId);\n      if (broadcastMessage) {\n        this._broadcastChatMessage({\n          type: MessageType.CF_AGENT_MESSAGE_UPDATED,\n          message: broadcastMessage\n        });\n      }\n    }\n\n    // Note: We don't automatically continue the conversation here.\n    // The client is responsible for sending a follow-up request if needed.\n    // This avoids re-entering onChatMessage with unexpected state.\n\n    return true;\n  }\n\n  private async _streamSSEReply(\n    id: string,\n    streamId: string,\n    reader: ReadableStreamDefaultReader<Uint8Array>,\n    message: ChatMessage,\n    streamCompleted: { value: boolean },\n    continuation = false\n  ) {\n    let activeTextParts: Record<string, TextUIPart> = {};\n    let activeReasoningParts: Record<string, ReasoningUIPart> = {};\n    const partialToolCalls: Record<\n      string,\n      { text: string; index: number; toolName: string; dynamic?: boolean }\n    > = {};\n\n    /* Lazy loading ai sdk, because putting it in module scope is\n     * causing issues with startup time.\n     * The only place it's used is in _reply, which only matters after\n     * a chat message is received.\n     * So it's safe to delay loading it until a chat message is received.\n     */\n    const { getToolName, isToolUIPart, parsePartialJson } = await import(\"ai\");\n\n    streamCompleted.value = false;\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        // Mark the stream as completed\n        this._completeStream(streamId);\n        streamCompleted.value = true;\n        // Send final completion signal\n        this._broadcastChatMessage({\n          body: \"\",\n          done: true,\n          id,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n          ...(continuation && { continuation: true })\n        });\n        break;\n      }\n\n      const chunk = decoder.decode(value);\n\n      // After streaming is complete, persist the complete assistant's response\n\n      // Parse AI SDK v5 SSE format and extract text deltas\n      const lines = chunk.split(\"\\n\");\n      for (const line of lines) {\n        if (line.startsWith(\"data: \") && line !== \"data: [DONE]\") {\n          try {\n            const data: UIMessageChunk = JSON.parse(line.slice(6)); // Remove 'data: ' prefix\n            switch (data.type) {\n              case \"text-start\": {\n                const textPart: TextUIPart = {\n                  type: \"text\",\n                  text: \"\",\n                  providerMetadata: data.providerMetadata,\n                  state: \"streaming\"\n                };\n                activeTextParts[data.id] = textPart;\n                message.parts.push(textPart);\n                break;\n              }\n\n              case \"text-delta\": {\n                const textPart = activeTextParts[data.id];\n                textPart.text += data.delta;\n                textPart.providerMetadata =\n                  data.providerMetadata ?? textPart.providerMetadata;\n                break;\n              }\n\n              case \"text-end\": {\n                const textPart = activeTextParts[data.id];\n                textPart.state = \"done\";\n                textPart.providerMetadata =\n                  data.providerMetadata ?? textPart.providerMetadata;\n                delete activeTextParts[data.id];\n                break;\n              }\n\n              case \"reasoning-start\": {\n                const reasoningPart: ReasoningUIPart = {\n                  type: \"reasoning\",\n                  text: \"\",\n                  providerMetadata: data.providerMetadata,\n                  state: \"streaming\"\n                };\n                activeReasoningParts[data.id] = reasoningPart;\n                message.parts.push(reasoningPart);\n                break;\n              }\n\n              case \"reasoning-delta\": {\n                const reasoningPart = activeReasoningParts[data.id];\n                reasoningPart.text += data.delta;\n                reasoningPart.providerMetadata =\n                  data.providerMetadata ?? reasoningPart.providerMetadata;\n                break;\n              }\n\n              case \"reasoning-end\": {\n                const reasoningPart = activeReasoningParts[data.id];\n                reasoningPart.providerMetadata =\n                  data.providerMetadata ?? reasoningPart.providerMetadata;\n                reasoningPart.state = \"done\";\n                delete activeReasoningParts[data.id];\n\n                break;\n              }\n\n              case \"file\": {\n                message.parts.push({\n                  type: \"file\",\n                  mediaType: data.mediaType,\n                  url: data.url\n                });\n\n                break;\n              }\n\n              case \"source-url\": {\n                message.parts.push({\n                  type: \"source-url\",\n                  sourceId: data.sourceId,\n                  url: data.url,\n                  title: data.title,\n                  providerMetadata: data.providerMetadata\n                });\n\n                break;\n              }\n\n              case \"source-document\": {\n                message.parts.push({\n                  type: \"source-document\",\n                  sourceId: data.sourceId,\n                  mediaType: data.mediaType,\n                  title: data.title,\n                  filename: data.filename,\n                  providerMetadata: data.providerMetadata\n                });\n\n                break;\n              }\n\n              case \"tool-input-start\": {\n                const toolInvocations = message.parts.filter(isToolUIPart);\n\n                // add the partial tool call to the map\n                partialToolCalls[data.toolCallId] = {\n                  text: \"\",\n                  toolName: data.toolName,\n                  index: toolInvocations.length,\n                  dynamic: data.dynamic\n                };\n\n                if (data.dynamic) {\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"input-streaming\",\n                    input: undefined\n                  });\n                } else {\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"input-streaming\",\n                    input: undefined\n                  });\n                }\n\n                break;\n              }\n\n              case \"tool-input-delta\": {\n                const partialToolCall = partialToolCalls[data.toolCallId];\n\n                partialToolCall.text += data.inputTextDelta;\n\n                const partialArgsResult = await parsePartialJson(\n                  partialToolCall.text\n                );\n                const partialArgs = (\n                  partialArgsResult as { value: Record<string, unknown> }\n                ).value;\n\n                if (partialToolCall.dynamic) {\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: partialToolCall.toolName,\n                    state: \"input-streaming\",\n                    input: partialArgs\n                  });\n                } else {\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: partialToolCall.toolName,\n                    state: \"input-streaming\",\n                    input: partialArgs\n                  });\n                }\n\n                break;\n              }\n\n              case \"tool-input-available\": {\n                if (data.dynamic) {\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"input-available\",\n                    input: data.input,\n                    providerMetadata: data.providerMetadata\n                  });\n                } else {\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"input-available\",\n                    input: data.input,\n                    providerExecuted: data.providerExecuted,\n                    providerMetadata: data.providerMetadata\n                  });\n                }\n\n                // TODO: Do we want to expose onToolCall?\n\n                // invoke the onToolCall callback if it exists. This is blocking.\n                // In the future we should make this non-blocking, which\n                // requires additional state management for error handling etc.\n                // Skip calling onToolCall for provider-executed tools since they are already executed\n                // if (onToolCall && !data.providerExecuted) {\n                //   await onToolCall({\n                //     toolCall: data\n                //   });\n                // }\n                break;\n              }\n\n              case \"tool-input-error\": {\n                if (data.dynamic) {\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"output-error\",\n                    input: data.input,\n                    errorText: data.errorText,\n                    providerMetadata: data.providerMetadata\n                  });\n                } else {\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: data.toolName,\n                    state: \"output-error\",\n                    input: undefined,\n                    rawInput: data.input,\n                    errorText: data.errorText,\n                    providerExecuted: data.providerExecuted,\n                    providerMetadata: data.providerMetadata\n                  });\n                }\n\n                break;\n              }\n\n              case \"tool-output-available\": {\n                if (data.dynamic) {\n                  const toolInvocations = message.parts.filter(\n                    (part) => part.type === \"dynamic-tool\"\n                  ) as DynamicToolUIPart[];\n\n                  const toolInvocation = toolInvocations.find(\n                    (invocation) => invocation.toolCallId === data.toolCallId\n                  );\n\n                  if (!toolInvocation)\n                    throw new Error(\"Tool invocation not found\");\n\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: toolInvocation.toolName,\n                    state: \"output-available\",\n                    input: toolInvocation.input,\n                    output: data.output,\n                    preliminary: data.preliminary\n                  });\n                } else {\n                  const toolInvocations = message.parts.filter(\n                    isToolUIPart\n                  ) as ToolUIPart[];\n\n                  const toolInvocation = toolInvocations.find(\n                    (invocation) => invocation.toolCallId === data.toolCallId\n                  );\n\n                  if (!toolInvocation)\n                    throw new Error(\"Tool invocation not found\");\n\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: getToolName(toolInvocation),\n                    state: \"output-available\",\n                    input: toolInvocation.input,\n                    output: data.output,\n                    providerExecuted: data.providerExecuted,\n                    preliminary: data.preliminary\n                  });\n                }\n\n                break;\n              }\n\n              case \"tool-output-error\": {\n                if (data.dynamic) {\n                  const toolInvocations = message.parts.filter(\n                    (part) => part.type === \"dynamic-tool\"\n                  ) as DynamicToolUIPart[];\n\n                  const toolInvocation = toolInvocations.find(\n                    (invocation) => invocation.toolCallId === data.toolCallId\n                  );\n\n                  if (!toolInvocation)\n                    throw new Error(\"Tool invocation not found\");\n\n                  this.updateDynamicToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: toolInvocation.toolName,\n                    state: \"output-error\",\n                    input: toolInvocation.input,\n                    errorText: data.errorText\n                  });\n                } else {\n                  const toolInvocations = message.parts.filter(\n                    isToolUIPart\n                  ) as ToolUIPart[];\n\n                  const toolInvocation = toolInvocations.find(\n                    (invocation) => invocation.toolCallId === data.toolCallId\n                  );\n\n                  if (!toolInvocation)\n                    throw new Error(\"Tool invocation not found\");\n                  await this.updateToolPart(message, {\n                    toolCallId: data.toolCallId,\n                    toolName: getToolName(toolInvocation),\n                    state: \"output-error\",\n                    input: toolInvocation.input,\n                    rawInput:\n                      \"rawInput\" in toolInvocation\n                        ? toolInvocation.rawInput\n                        : undefined,\n                    errorText: data.errorText\n                  });\n                }\n\n                break;\n              }\n\n              case \"start-step\": {\n                // add a step boundary part to the message\n                message.parts.push({ type: \"step-start\" });\n                break;\n              }\n\n              case \"finish-step\": {\n                // reset the current text and reasoning parts\n                activeTextParts = {};\n                activeReasoningParts = {};\n                break;\n              }\n\n              case \"start\": {\n                if (data.messageId != null) {\n                  message.id = data.messageId;\n                }\n\n                await this.updateMessageMetadata(message, data.messageMetadata);\n\n                break;\n              }\n\n              case \"finish\": {\n                await this.updateMessageMetadata(message, data.messageMetadata);\n                break;\n              }\n\n              case \"message-metadata\": {\n                await this.updateMessageMetadata(message, data.messageMetadata);\n                break;\n              }\n\n              case \"error\": {\n                this._broadcastChatMessage({\n                  error: true,\n                  body: data.errorText ?? JSON.stringify(data),\n                  done: false,\n                  id,\n                  type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                });\n\n                break;\n              }\n              // Do we want to handle data parts?\n            }\n\n            // Convert internal AI SDK stream events to valid UIMessageStreamPart format.\n            // The \"finish\" event with \"finishReason\" is an internal LanguageModelV3StreamPart,\n            // not a UIMessageStreamPart (which expects \"messageMetadata\" instead).\n            // See: https://github.com/cloudflare/agents/issues/677\n            let eventToSend: unknown = data;\n            if (data.type === \"finish\" && \"finishReason\" in data) {\n              const { finishReason, ...rest } = data as {\n                finishReason: string;\n                [key: string]: unknown;\n              };\n              eventToSend = {\n                ...rest,\n                type: \"finish\",\n                messageMetadata: { finishReason }\n              };\n            }\n\n            // Store chunk for replay on reconnection\n            const chunkBody = JSON.stringify(eventToSend);\n            this._storeStreamChunk(streamId, chunkBody);\n\n            // Forward the converted event to the client\n            this._broadcastChatMessage({\n              body: chunkBody,\n              done: false,\n              id,\n              type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n              ...(continuation && { continuation: true })\n            });\n          } catch (_error) {\n            // Skip malformed JSON lines silently\n          }\n        }\n      }\n    }\n  }\n\n  // Handle plain text responses (e.g., from generateText)\n  private async _sendPlaintextReply(\n    id: string,\n    streamId: string,\n    reader: ReadableStreamDefaultReader<Uint8Array>,\n    message: ChatMessage,\n    streamCompleted: { value: boolean },\n    continuation = false\n  ) {\n    // if not AI SDK SSE format, we need to inject text-start and text-end events ourselves\n    this._broadcastTextEvent(\n      streamId,\n      { type: \"text-start\", id },\n      continuation\n    );\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        this._broadcastTextEvent(\n          streamId,\n          { type: \"text-end\", id },\n          continuation\n        );\n\n        // Mark the stream as completed\n        this._completeStream(streamId);\n        streamCompleted.value = true;\n        // Send final completion signal\n        this._broadcastChatMessage({\n          body: \"\",\n          done: true,\n          id,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n          ...(continuation && { continuation: true })\n        });\n        break;\n      }\n\n      const chunk = decoder.decode(value);\n\n      // Treat the entire chunk as a text delta to preserve exact formatting\n      if (chunk.length > 0) {\n        message.parts.push({ type: \"text\", text: chunk });\n        this._broadcastTextEvent(\n          streamId,\n          { type: \"text-delta\", id, delta: chunk },\n          continuation\n        );\n      }\n    }\n  }\n\n  private updateDynamicToolPart(\n    message: ChatMessage,\n    options: {\n      toolName: string;\n      toolCallId: string;\n      providerExecuted?: boolean;\n    } & (\n      | {\n          state: \"input-streaming\";\n          input: unknown;\n        }\n      | {\n          state: \"input-available\";\n          input: unknown;\n          providerMetadata?: ProviderMetadata;\n        }\n      | {\n          state: \"output-available\";\n          input: unknown;\n          output: unknown;\n          preliminary: boolean | undefined;\n        }\n      | {\n          state: \"output-error\";\n          input: unknown;\n          errorText: string;\n          providerMetadata?: ProviderMetadata;\n        }\n    )\n  ) {\n    const part = message.parts.find(\n      (part) =>\n        part.type === \"dynamic-tool\" && part.toolCallId === options.toolCallId\n    ) as DynamicToolUIPart | undefined;\n\n    const anyOptions = options as Record<string, unknown>;\n    const anyPart = part as Record<string, unknown>;\n\n    if (part != null) {\n      part.state = options.state;\n      anyPart.toolName = options.toolName;\n      anyPart.input = anyOptions.input;\n      anyPart.output = anyOptions.output;\n      anyPart.errorText = anyOptions.errorText;\n      anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;\n      anyPart.preliminary = anyOptions.preliminary;\n\n      if (\n        anyOptions.providerMetadata != null &&\n        part.state === \"input-available\"\n      ) {\n        part.callProviderMetadata =\n          anyOptions.providerMetadata as ProviderMetadata;\n      }\n    } else {\n      message.parts.push({\n        type: \"dynamic-tool\",\n        toolName: options.toolName,\n        toolCallId: options.toolCallId,\n        state: options.state,\n        input: anyOptions.input,\n        output: anyOptions.output,\n        errorText: anyOptions.errorText,\n        preliminary: anyOptions.preliminary,\n        ...(anyOptions.providerMetadata != null\n          ? { callProviderMetadata: anyOptions.providerMetadata }\n          : {})\n      } as DynamicToolUIPart);\n    }\n  }\n\n  private async updateToolPart(\n    message: ChatMessage,\n    options: {\n      toolName: string;\n      toolCallId: string;\n      providerExecuted?: boolean;\n    } & (\n      | {\n          state: \"input-streaming\";\n          input: unknown;\n          providerExecuted?: boolean;\n        }\n      | {\n          state: \"input-available\";\n          input: unknown;\n          providerExecuted?: boolean;\n          providerMetadata?: ProviderMetadata;\n        }\n      | {\n          state: \"output-available\";\n          input: unknown;\n          output: unknown;\n          providerExecuted?: boolean;\n          preliminary?: boolean;\n        }\n      | {\n          state: \"output-error\";\n          input: unknown;\n          rawInput?: unknown;\n          errorText: string;\n          providerExecuted?: boolean;\n          providerMetadata?: ProviderMetadata;\n        }\n    )\n  ) {\n    const { isToolUIPart } = await import(\"ai\");\n\n    const part = message.parts.find(\n      (part) =>\n        isToolUIPart(part) &&\n        (part as ToolUIPart).toolCallId === options.toolCallId\n    ) as ToolUIPart | undefined;\n\n    const anyOptions = options as Record<string, unknown>;\n    const anyPart = part as Record<string, unknown>;\n\n    if (part != null) {\n      part.state = options.state;\n      anyPart.input = anyOptions.input;\n      anyPart.output = anyOptions.output;\n      anyPart.errorText = anyOptions.errorText;\n      anyPart.rawInput = anyOptions.rawInput;\n      anyPart.preliminary = anyOptions.preliminary;\n\n      // once providerExecuted is set, it stays for streaming\n      anyPart.providerExecuted =\n        anyOptions.providerExecuted ?? part.providerExecuted;\n\n      if (\n        anyOptions.providerMetadata != null &&\n        part.state === \"input-available\"\n      ) {\n        part.callProviderMetadata =\n          anyOptions.providerMetadata as ProviderMetadata;\n      }\n    } else {\n      message.parts.push({\n        type: `tool-${options.toolName}`,\n        toolCallId: options.toolCallId,\n        state: options.state,\n        input: anyOptions.input,\n        output: anyOptions.output,\n        rawInput: anyOptions.rawInput,\n        errorText: anyOptions.errorText,\n        providerExecuted: anyOptions.providerExecuted,\n        preliminary: anyOptions.preliminary,\n        ...(anyOptions.providerMetadata != null\n          ? { callProviderMetadata: anyOptions.providerMetadata }\n          : {})\n      } as ToolUIPart);\n    }\n  }\n\n  private async updateMessageMetadata(message: ChatMessage, metadata: unknown) {\n    if (metadata != null) {\n      const mergedMetadata =\n        message.metadata != null\n          ? { ...message.metadata, ...metadata } // TODO: do proper merging\n          : metadata;\n\n      message.metadata = mergedMetadata;\n    }\n  }\n\n  /**\n   * Applies a tool approval response from the client, updating the persisted message.\n   * This is called when the client sends CF_AGENT_TOOL_APPROVAL for tools with needsApproval.\n   * Updates the tool part state from input-available/approval-requested to approval-responded.\n   *\n   * @param toolCallId - The tool call ID this approval is for\n   * @param approved - Whether the tool execution was approved\n   * @returns true if the approval was applied, false if the message was not found\n   */\n  private async _applyToolApproval(\n    toolCallId: string,\n    approved: boolean\n  ): Promise<boolean> {\n    // Find the message with this tool call.\n    // We check two locations:\n    // 1. _streamingMessage: in-memory message being actively built during AI response\n    //    (not yet persisted to SQLite or available in this.messages)\n    // 2. this.messages: persisted messages loaded from SQLite database\n    //\n    // The user can approve before streaming finishes (e.g., approval UI appears\n    // while AI is still generating text), so we must check _streamingMessage first.\n\n    let message: ChatMessage | undefined;\n\n    // Check streaming message first (in-memory, not yet persisted)\n    if (this._streamingMessage) {\n      for (const part of this._streamingMessage.parts) {\n        if (\"toolCallId\" in part && part.toolCallId === toolCallId) {\n          message = this._streamingMessage;\n          break;\n        }\n      }\n    }\n\n    // If not found in streaming message, check persisted messages (in SQLite).\n    // Retry with backoff in case streaming completes and persists between attempts.\n    if (!message) {\n      for (let attempt = 0; attempt < 10; attempt++) {\n        message = this._findMessageByToolCallId(toolCallId);\n        if (message) break;\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n\n    if (!message) {\n      console.warn(\n        `[AIChatAgent] _applyToolApproval: Could not find message with toolCallId ${toolCallId} after retries`\n      );\n      return false;\n    }\n\n    // Check if this is the streaming message (not yet persisted)\n    const isStreamingMessage = message === this._streamingMessage;\n\n    // Update the tool part with the approval\n    let updated = false;\n    if (isStreamingMessage) {\n      // Update in place - the message will be persisted when streaming completes\n      for (const part of message.parts) {\n        if (\n          \"toolCallId\" in part &&\n          part.toolCallId === toolCallId &&\n          \"state\" in part &&\n          (part.state === \"input-available\" ||\n            part.state === \"approval-requested\")\n        ) {\n          (part as { state: string; approval?: { approved: boolean } }).state =\n            \"approval-responded\";\n          (\n            part as { state: string; approval?: { approved: boolean } }\n          ).approval = { approved };\n          updated = true;\n          break;\n        }\n      }\n    } else {\n      // For persisted messages, create updated parts\n      const updatedParts = message.parts.map((part) => {\n        if (\n          \"toolCallId\" in part &&\n          part.toolCallId === toolCallId &&\n          \"state\" in part &&\n          (part.state === \"input-available\" ||\n            part.state === \"approval-requested\")\n        ) {\n          updated = true;\n          return {\n            ...part,\n            state: \"approval-responded\" as const,\n            approval: { approved }\n          };\n        }\n        return part;\n      }) as ChatMessage[\"parts\"];\n\n      if (updated) {\n        // Create the updated message and strip OpenAI item IDs\n        const updatedMessage: ChatMessage = this._sanitizeMessageForPersistence(\n          {\n            ...message,\n            parts: updatedParts\n          }\n        );\n\n        // Persist the updated message\n        this.sql`\n          update cf_ai_chat_agent_messages \n          set message = ${JSON.stringify(updatedMessage)}\n          where id = ${message.id}\n        `;\n\n        // Reload messages to update in-memory state\n        const persisted = this._loadMessagesFromDb();\n        this.messages = autoTransformMessages(persisted);\n      }\n    }\n\n    if (!updated) {\n      console.warn(\n        `[AIChatAgent] _applyToolApproval: Tool part with toolCallId ${toolCallId} not in input-available or approval-requested state`\n      );\n      return false;\n    }\n\n    // Broadcast the update to all clients (only for persisted messages)\n    if (!isStreamingMessage) {\n      const broadcastMessage = this._findMessageByToolCallId(toolCallId);\n      if (broadcastMessage) {\n        this._broadcastChatMessage({\n          type: MessageType.CF_AGENT_MESSAGE_UPDATED,\n          message: broadcastMessage\n        });\n      }\n    }\n\n    return true;\n  }\n\n  private async _reply(\n    id: string,\n    response: Response,\n    excludeBroadcastIds: string[] = [],\n    options: { continuation?: boolean } = {}\n  ) {\n    const { continuation = false } = options;\n\n    return this._tryCatchChat(async () => {\n      if (!response.body) {\n        // Send empty response if no body\n        this._broadcastChatMessage({\n          body: \"\",\n          done: true,\n          id,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n          ...(continuation && { continuation: true })\n        });\n        return;\n      }\n\n      // Start tracking this stream for resumability\n      const streamId = this._startStream(id);\n\n      const reader = response.body.getReader();\n\n      // Parsing state adapted from:\n      // https://github.com/vercel/ai/blob/main/packages/ai/src/ui-message-stream/ui-message-chunks.ts#L295\n      const message: ChatMessage = {\n        id: `assistant_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`, // default\n        role: \"assistant\",\n        parts: []\n      };\n      // Track the streaming message so tool results can be applied before persistence\n      this._streamingMessage = message;\n      // Set up completion promise for tool continuation to wait on\n      this._streamCompletionPromise = new Promise((resolve) => {\n        this._streamCompletionResolve = resolve;\n      });\n\n      // Determine response format based on content-type\n      const contentType = response.headers.get(\"content-type\") || \"\";\n      const isSSE = contentType.includes(\"text/event-stream\"); // AI SDK v5 SSE format\n      const streamCompleted = { value: false };\n\n      try {\n        if (isSSE) {\n          // AI SDK v5 SSE format\n          await this._streamSSEReply(\n            id,\n            streamId,\n            reader,\n            message,\n            streamCompleted,\n            continuation\n          );\n        } else {\n          await this._sendPlaintextReply(\n            id,\n            streamId,\n            reader,\n            message,\n            streamCompleted,\n            continuation\n          );\n        }\n      } catch (error) {\n        // Mark stream as error if not already completed\n        if (!streamCompleted.value) {\n          this._markStreamError(streamId);\n          // Notify clients of the error\n          this._broadcastChatMessage({\n            body: error instanceof Error ? error.message : \"Stream error\",\n            done: true,\n            error: true,\n            id,\n            type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,\n            ...(continuation && { continuation: true })\n          });\n        }\n        throw error;\n      } finally {\n        reader.releaseLock();\n      }\n\n      if (message.parts.length > 0) {\n        if (continuation) {\n          // Find the last assistant message and append parts to it\n          let lastAssistantIdx = -1;\n          for (let i = this.messages.length - 1; i >= 0; i--) {\n            if (this.messages[i].role === \"assistant\") {\n              lastAssistantIdx = i;\n              break;\n            }\n          }\n          if (lastAssistantIdx >= 0) {\n            const lastAssistant = this.messages[lastAssistantIdx];\n            const mergedMessage: ChatMessage = {\n              ...lastAssistant,\n              parts: [...lastAssistant.parts, ...message.parts]\n            };\n            const updatedMessages = [...this.messages];\n            updatedMessages[lastAssistantIdx] = mergedMessage;\n            await this.persistMessages(updatedMessages, excludeBroadcastIds);\n          } else {\n            // No assistant message to append to, create new one\n            await this.persistMessages(\n              [...this.messages, message],\n              excludeBroadcastIds\n            );\n          }\n        } else {\n          await this.persistMessages(\n            [...this.messages, message],\n            excludeBroadcastIds\n          );\n        }\n      }\n\n      // Clear the streaming message reference and resolve completion promise\n      this._streamingMessage = null;\n      if (this._streamCompletionResolve) {\n        this._streamCompletionResolve();\n        this._streamCompletionResolve = null;\n        this._streamCompletionPromise = null;\n      }\n    });\n  }\n\n  /**\n   * Mark a stream as errored and clean up state.\n   * @param streamId - The stream to mark as errored\n   * @internal Protected for testing purposes.\n   */\n  protected _markStreamError(streamId: string) {\n    // Flush any pending chunks before marking error\n    this._flushChunkBuffer();\n\n    this.sql`\n      update cf_ai_chat_stream_metadata \n      set status = 'error', completed_at = ${Date.now()} \n      where id = ${streamId}\n    `;\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n    this._streamChunkIndex = 0;\n  }\n\n  /**\n   * For the given message id, look up its associated AbortController\n   * If the AbortController does not exist, create and store one in memory\n   *\n   * returns the AbortSignal associated with the AbortController\n   */\n  private _getAbortSignal(id: string): AbortSignal | undefined {\n    // Defensive check, since we're coercing message types at the moment\n    if (typeof id !== \"string\") {\n      return undefined;\n    }\n\n    if (!this._chatMessageAbortControllers.has(id)) {\n      this._chatMessageAbortControllers.set(id, new AbortController());\n    }\n\n    return this._chatMessageAbortControllers.get(id)?.signal;\n  }\n\n  /**\n   * Remove an abort controller from the cache of pending message responses\n   */\n  private _removeAbortController(id: string) {\n    this._chatMessageAbortControllers.delete(id);\n  }\n\n  /**\n   * Propagate an abort signal for any requests associated with the given message id\n   */\n  private _cancelChatRequest(id: string) {\n    if (this._chatMessageAbortControllers.has(id)) {\n      const abortController = this._chatMessageAbortControllers.get(id);\n      abortController?.abort();\n    }\n  }\n\n  /**\n   * Abort all pending requests and clear the cache of AbortControllers\n   */\n  private _destroyAbortControllers() {\n    for (const controller of this._chatMessageAbortControllers.values()) {\n      controller?.abort();\n    }\n    this._chatMessageAbortControllers.clear();\n  }\n\n  /**\n   * When the DO is destroyed, cancel all pending requests and clean up resources\n   */\n  async destroy() {\n    this._destroyAbortControllers();\n\n    // Flush any remaining chunks before cleanup\n    this._flushChunkBuffer();\n\n    // Clean up stream tables\n    this.sql`drop table if exists cf_ai_chat_stream_chunks`;\n    this.sql`drop table if exists cf_ai_chat_stream_metadata`;\n\n    // Clear active stream state\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n\n    await super.destroy();\n  }\n}\n"],"mappings":"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"}