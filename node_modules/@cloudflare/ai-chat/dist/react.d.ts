import { ChatInit, JSONSchema7, Tool, UIMessage } from "ai";
import { UseChatOptions, useChat } from "@ai-sdk/react";
import { useAgent } from "agents/react";

//#region src/react.d.ts
/**
 * JSON Schema type for tool parameters.
 * Re-exported from the AI SDK for convenience.
 * @deprecated Import JSONSchema7 directly from "ai" instead.
 */
type JSONSchemaType = JSONSchema7;
/**
 * Definition for a tool that can be executed on the client.
 * Tools with an `execute` function are automatically registered with the server.
 *
 * Note: Uses `parameters` (JSONSchema7) rather than AI SDK's `inputSchema` (FlexibleSchema)
 * because client tools must be serializable for the wire format. Zod schemas cannot be
 * serialized, so we require raw JSON Schema here.
 *
 * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server with
 * `tool()` from "ai", and handle client-side execution via the `onToolCall` callback
 * in `useAgentChat`. For tools requiring user approval, use `needsApproval` on the server.
 */
type AITool<Input = unknown, Output = unknown> = {
  /** Human-readable description of what the tool does */ description?: Tool["description"] /** JSON Schema defining the tool's input parameters */;
  parameters?: JSONSchema7;
  /**
   * @deprecated Use `parameters` instead. Will be removed in a future version.
   */
  inputSchema?: JSONSchema7;
  /**
   * Function to execute the tool on the client.
   * If provided, the tool schema is automatically sent to the server.
   */
  execute?: (input: Input) => Output | Promise<Output>;
};
/**
 * Schema for a client tool sent to the server.
 * This is the wire format - what gets sent in the request body.
 * Must match the server-side ClientToolSchema type in ai-chat-agent.ts.
 *
 * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server.
 */
type ClientToolSchema = {
  /** Unique name for the tool */ name: string /** Human-readable description of what the tool does */;
  description?: Tool["description"] /** JSON Schema defining the tool's input parameters */;
  parameters?: JSONSchema7;
};
/**
 * Extracts tool schemas from tools that have client-side execute functions.
 * These schemas are automatically sent to the server with each request.
 * @param tools - Record of tool name to tool definition
 * @returns Array of tool schemas to send to server, or undefined if none
 *
 * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server
 * and use `onToolCall` callback for client-side execution.
 */
declare function extractClientToolSchemas(
  tools?: Record<string, AITool<unknown, unknown>>
): ClientToolSchema[] | undefined;
type GetInitialMessagesOptions = {
  agent: string;
  name: string;
  url: string;
};
type UseChatParams<M extends UIMessage = UIMessage> = ChatInit<M> &
  UseChatOptions<M>;
/**
 * Options for preparing the send messages request.
 * Used by prepareSendMessagesRequest callback.
 */
type PrepareSendMessagesRequestOptions<
  ChatMessage extends UIMessage = UIMessage
> = {
  /** The chat ID */ id: string /** Messages to send */;
  messages: ChatMessage[] /** What triggered this request */;
  trigger:
    | "submit-message"
    | "regenerate-message" /** ID of the message being sent (if applicable) */;
  messageId?: string /** Request metadata */;
  requestMetadata?: unknown /** Current body (if any) */;
  body?: Record<string, unknown> /** Current credentials (if any) */;
  credentials?: RequestCredentials /** Current headers (if any) */;
  headers?: HeadersInit /** API endpoint */;
  api?: string;
};
/**
 * Return type for prepareSendMessagesRequest callback.
 * Allows customizing headers, body, and credentials for each request.
 * All fields are optional; only specify what you need to customize.
 */
type PrepareSendMessagesRequestResult = {
  /** Custom headers to send with the request */ headers?: HeadersInit /** Custom body data to merge with the request */;
  body?: Record<string, unknown> /** Custom credentials option */;
  credentials?: RequestCredentials /** Custom API endpoint */;
  api?: string;
};
/**
 * Callback for handling client-side tool execution.
 * Called when a tool without server-side execute is invoked.
 */
type OnToolCallCallback = (options: {
  /** The tool call that needs to be handled */ toolCall: {
    toolCallId: string;
    toolName: string;
    input: unknown;
  } /** Function to provide the tool output */;
  addToolOutput: (options: { toolCallId: string; output: unknown }) => void;
}) => void | Promise<void>;
/**
 * Options for the useAgentChat hook
 */
type UseAgentChatOptions<
  State,
  ChatMessage extends UIMessage = UIMessage
> = Omit<UseChatParams<ChatMessage>, "fetch"> & {
  /** Agent connection from useAgent */ agent: ReturnType<
    typeof useAgent<State>
  >;
  getInitialMessages?:
    | undefined
    | null
    | ((
        options: GetInitialMessagesOptions
      ) => Promise<ChatMessage[]>) /** Request credentials */;
  credentials?: RequestCredentials /** Request headers */;
  headers?: HeadersInit;
  /**
   * Callback for handling client-side tool execution.
   * Called when a tool without server-side `execute` is invoked by the LLM.
   *
   * Use this for:
   * - Tools that need browser APIs (geolocation, camera, etc.)
   * - Tools that need user interaction before providing a result
   * - Tools requiring approval before execution
   *
   * @example
   * ```typescript
   * onToolCall: async ({ toolCall, addToolOutput }) => {
   *   if (toolCall.toolName === 'getLocation') {
   *     const position = await navigator.geolocation.getCurrentPosition();
   *     addToolOutput({
   *       toolCallId: toolCall.toolCallId,
   *       output: { lat: position.coords.latitude, lng: position.coords.longitude }
   *     });
   *   }
   * }
   * ```
   */
  onToolCall?: OnToolCallCallback;
  /**
   * @deprecated Use `onToolCall` callback instead for automatic tool execution.
   * @description Whether to automatically resolve tool calls that do not require human interaction.
   * @experimental
   */
  experimental_automaticToolResolution?: boolean;
  /**
   * @deprecated Use `onToolCall` callback instead. Define tools on the server
   * and handle client-side execution via `onToolCall`.
   *
   * Tools that can be executed on the client.
   */
  tools?: Record<string, AITool<unknown, unknown>>;
  /**
   * @deprecated Use `needsApproval` on server-side tools instead.
   * @description Manual override for tools requiring confirmation.
   * If not provided, will auto-detect from tools object (tools without execute require confirmation).
   */
  toolsRequiringConfirmation?: string[];
  /**
   * When true, the server automatically continues the conversation after
   * receiving client-side tool results, similar to how server-executed tools
   * work with maxSteps in streamText. The continuation is merged into the
   * same assistant message.
   *
   * When false (default), the client calls sendMessage() after tool results
   * to continue the conversation, which creates a new assistant message.
   *
   * @default false
   */
  autoContinueAfterToolResult?: boolean;
  /**
   * @deprecated Use `sendAutomaticallyWhen` from AI SDK instead.
   *
   * When true (default), automatically sends the next message only after
   * all pending confirmation-required tool calls have been resolved.
   * When false, sends immediately after each tool result.
   *
   * Only applies when `autoContinueAfterToolResult` is false.
   *
   * @default true
   */
  autoSendAfterAllConfirmationsResolved?: boolean;
  /**
   * Set to false to disable automatic stream resumption.
   * @default true
   */
  resume?: boolean;
  /**
   * Callback to customize the request before sending messages.
   * Use this for advanced scenarios like adding custom headers or dynamic context.
   *
   * Note: Client tool schemas are automatically sent when tools have `execute` functions.
   * This callback can add additional data alongside the auto-extracted schemas.
   */
  prepareSendMessagesRequest?: (
    options: PrepareSendMessagesRequestOptions<ChatMessage>
  ) =>
    | PrepareSendMessagesRequestResult
    | Promise<PrepareSendMessagesRequestResult>;
};
/**
 * React hook for building AI chat interfaces using an Agent
 * @param options Chat options including the agent connection
 * @returns Chat interface controls and state with added clearHistory method
 */
/**
 * Automatically detects which tools require confirmation based on their configuration.
 * Tools require confirmation if they have no execute function AND are not server-executed.
 * @param tools - Record of tool name to tool definition
 * @returns Array of tool names that require confirmation
 *
 * @deprecated Use `needsApproval` on server-side tools instead.
 */
declare function detectToolsRequiringConfirmation(
  tools?: Record<string, AITool<unknown, unknown>>
): string[];
/**
 * Return type for addToolOutput function
 */
type AddToolOutputOptions = {
  /** The ID of the tool call to provide output for */ toolCallId: string /** The name of the tool (optional, for type safety) */;
  toolName?: string /** The output to provide */;
  output: unknown;
};
declare function useAgentChat<
  State = unknown,
  ChatMessage extends UIMessage = UIMessage
>(
  options: UseAgentChatOptions<State, ChatMessage>
): Omit<ReturnType<typeof useChat<ChatMessage>>, "addToolOutput"> & {
  clearHistory: () => void;
  /**
   * Provide output for a tool call. Use this for tools that require user interaction
   * or client-side execution.
   */
  addToolOutput: (opts: AddToolOutputOptions) => void;
};
//#endregion
export {
  AITool,
  ClientToolSchema,
  JSONSchemaType,
  OnToolCallCallback,
  PrepareSendMessagesRequestOptions,
  PrepareSendMessagesRequestResult,
  detectToolsRequiringConfirmation,
  extractClientToolSchemas,
  useAgentChat
};
//# sourceMappingURL=react.d.ts.map
