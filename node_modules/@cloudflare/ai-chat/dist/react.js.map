{"version":3,"file":"react.js","names":[],"sources":["../src/react.tsx"],"sourcesContent":["import { useChat, type UseChatOptions } from \"@ai-sdk/react\";\nimport { getToolName, isToolUIPart } from \"ai\";\nimport type {\n  ChatInit,\n  ChatTransport,\n  JSONSchema7,\n  Tool,\n  UIMessage as Message,\n  UIMessage\n} from \"ai\";\nimport { DefaultChatTransport } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport { use, useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type { OutgoingMessage } from \"./types\";\nimport { MessageType } from \"./types\";\nimport type { useAgent } from \"agents/react\";\n\n/**\n * JSON Schema type for tool parameters.\n * Re-exported from the AI SDK for convenience.\n * @deprecated Import JSONSchema7 directly from \"ai\" instead.\n */\nexport type JSONSchemaType = JSONSchema7;\n\n/**\n * Definition for a tool that can be executed on the client.\n * Tools with an `execute` function are automatically registered with the server.\n *\n * Note: Uses `parameters` (JSONSchema7) rather than AI SDK's `inputSchema` (FlexibleSchema)\n * because client tools must be serializable for the wire format. Zod schemas cannot be\n * serialized, so we require raw JSON Schema here.\n *\n * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server with\n * `tool()` from \"ai\", and handle client-side execution via the `onToolCall` callback\n * in `useAgentChat`. For tools requiring user approval, use `needsApproval` on the server.\n */\nexport type AITool<Input = unknown, Output = unknown> = {\n  /** Human-readable description of what the tool does */\n  description?: Tool[\"description\"];\n  /** JSON Schema defining the tool's input parameters */\n  parameters?: JSONSchema7;\n  /**\n   * @deprecated Use `parameters` instead. Will be removed in a future version.\n   */\n  inputSchema?: JSONSchema7;\n  /**\n   * Function to execute the tool on the client.\n   * If provided, the tool schema is automatically sent to the server.\n   */\n  execute?: (input: Input) => Output | Promise<Output>;\n};\n\n/**\n * Schema for a client tool sent to the server.\n * This is the wire format - what gets sent in the request body.\n * Must match the server-side ClientToolSchema type in ai-chat-agent.ts.\n *\n * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server.\n */\nexport type ClientToolSchema = {\n  /** Unique name for the tool */\n  name: string;\n  /** Human-readable description of what the tool does */\n  description?: Tool[\"description\"];\n  /** JSON Schema defining the tool's input parameters */\n  parameters?: JSONSchema7;\n};\n\n/**\n * Extracts tool schemas from tools that have client-side execute functions.\n * These schemas are automatically sent to the server with each request.\n * @param tools - Record of tool name to tool definition\n * @returns Array of tool schemas to send to server, or undefined if none\n *\n * @deprecated Use AI SDK's native tool pattern instead. Define tools on the server\n * and use `onToolCall` callback for client-side execution.\n */\nexport function extractClientToolSchemas(\n  tools?: Record<string, AITool<unknown, unknown>>\n): ClientToolSchema[] | undefined {\n  if (!tools) return undefined;\n\n  const schemas: ClientToolSchema[] = Object.entries(tools)\n    .filter(([_, tool]) => tool.execute) // Only tools with client-side execute\n    .map(([name, tool]) => {\n      if (tool.inputSchema && !tool.parameters) {\n        console.warn(\n          `[useAgentChat] Tool \"${name}\" uses deprecated 'inputSchema'. Please migrate to 'parameters'.`\n        );\n      }\n      return {\n        name,\n        description: tool.description,\n        parameters: tool.parameters ?? tool.inputSchema\n      };\n    });\n\n  return schemas.length > 0 ? schemas : undefined;\n}\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n// v5 useChat parameters\ntype UseChatParams<M extends UIMessage = UIMessage> = ChatInit<M> &\n  UseChatOptions<M>;\n\n/**\n * Options for preparing the send messages request.\n * Used by prepareSendMessagesRequest callback.\n */\nexport type PrepareSendMessagesRequestOptions<\n  ChatMessage extends UIMessage = UIMessage\n> = {\n  /** The chat ID */\n  id: string;\n  /** Messages to send */\n  messages: ChatMessage[];\n  /** What triggered this request */\n  trigger: \"submit-message\" | \"regenerate-message\";\n  /** ID of the message being sent (if applicable) */\n  messageId?: string;\n  /** Request metadata */\n  requestMetadata?: unknown;\n  /** Current body (if any) */\n  body?: Record<string, unknown>;\n  /** Current credentials (if any) */\n  credentials?: RequestCredentials;\n  /** Current headers (if any) */\n  headers?: HeadersInit;\n  /** API endpoint */\n  api?: string;\n};\n\n/**\n * Return type for prepareSendMessagesRequest callback.\n * Allows customizing headers, body, and credentials for each request.\n * All fields are optional; only specify what you need to customize.\n */\nexport type PrepareSendMessagesRequestResult = {\n  /** Custom headers to send with the request */\n  headers?: HeadersInit;\n  /** Custom body data to merge with the request */\n  body?: Record<string, unknown>;\n  /** Custom credentials option */\n  credentials?: RequestCredentials;\n  /** Custom API endpoint */\n  api?: string;\n};\n\n/**\n * Internal type for AI SDK transport\n * @internal\n */\ntype InternalPrepareResult = {\n  body: Record<string, unknown>;\n  headers?: HeadersInit;\n  credentials?: RequestCredentials;\n  api?: string;\n};\n\n/**\n * Callback for handling client-side tool execution.\n * Called when a tool without server-side execute is invoked.\n */\nexport type OnToolCallCallback = (options: {\n  /** The tool call that needs to be handled */\n  toolCall: {\n    toolCallId: string;\n    toolName: string;\n    input: unknown;\n  };\n  /** Function to provide the tool output */\n  addToolOutput: (options: { toolCallId: string; output: unknown }) => void;\n}) => void | Promise<void>;\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<\n  State,\n  ChatMessage extends UIMessage = UIMessage\n> = Omit<UseChatParams<ChatMessage>, \"fetch\"> & {\n  /** Agent connection from useAgent */\n  agent: ReturnType<typeof useAgent<State>>;\n  getInitialMessages?:\n    | undefined\n    | null\n    | ((options: GetInitialMessagesOptions) => Promise<ChatMessage[]>);\n  /** Request credentials */\n  credentials?: RequestCredentials;\n  /** Request headers */\n  headers?: HeadersInit;\n  /**\n   * Callback for handling client-side tool execution.\n   * Called when a tool without server-side `execute` is invoked by the LLM.\n   *\n   * Use this for:\n   * - Tools that need browser APIs (geolocation, camera, etc.)\n   * - Tools that need user interaction before providing a result\n   * - Tools requiring approval before execution\n   *\n   * @example\n   * ```typescript\n   * onToolCall: async ({ toolCall, addToolOutput }) => {\n   *   if (toolCall.toolName === 'getLocation') {\n   *     const position = await navigator.geolocation.getCurrentPosition();\n   *     addToolOutput({\n   *       toolCallId: toolCall.toolCallId,\n   *       output: { lat: position.coords.latitude, lng: position.coords.longitude }\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  onToolCall?: OnToolCallCallback;\n  /**\n   * @deprecated Use `onToolCall` callback instead for automatic tool execution.\n   * @description Whether to automatically resolve tool calls that do not require human interaction.\n   * @experimental\n   */\n  experimental_automaticToolResolution?: boolean;\n  /**\n   * @deprecated Use `onToolCall` callback instead. Define tools on the server\n   * and handle client-side execution via `onToolCall`.\n   *\n   * Tools that can be executed on the client.\n   */\n  tools?: Record<string, AITool<unknown, unknown>>;\n  /**\n   * @deprecated Use `needsApproval` on server-side tools instead.\n   * @description Manual override for tools requiring confirmation.\n   * If not provided, will auto-detect from tools object (tools without execute require confirmation).\n   */\n  toolsRequiringConfirmation?: string[];\n  /**\n   * When true, the server automatically continues the conversation after\n   * receiving client-side tool results, similar to how server-executed tools\n   * work with maxSteps in streamText. The continuation is merged into the\n   * same assistant message.\n   *\n   * When false (default), the client calls sendMessage() after tool results\n   * to continue the conversation, which creates a new assistant message.\n   *\n   * @default false\n   */\n  autoContinueAfterToolResult?: boolean;\n  /**\n   * @deprecated Use `sendAutomaticallyWhen` from AI SDK instead.\n   *\n   * When true (default), automatically sends the next message only after\n   * all pending confirmation-required tool calls have been resolved.\n   * When false, sends immediately after each tool result.\n   *\n   * Only applies when `autoContinueAfterToolResult` is false.\n   *\n   * @default true\n   */\n  autoSendAfterAllConfirmationsResolved?: boolean;\n  /**\n   * Set to false to disable automatic stream resumption.\n   * @default true\n   */\n  resume?: boolean;\n  /**\n   * Callback to customize the request before sending messages.\n   * Use this for advanced scenarios like adding custom headers or dynamic context.\n   *\n   * Note: Client tool schemas are automatically sent when tools have `execute` functions.\n   * This callback can add additional data alongside the auto-extracted schemas.\n   */\n  prepareSendMessagesRequest?: (\n    options: PrepareSendMessagesRequestOptions<ChatMessage>\n  ) =>\n    | PrepareSendMessagesRequestResult\n    | Promise<PrepareSendMessagesRequestResult>;\n};\n\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\n/**\n * Automatically detects which tools require confirmation based on their configuration.\n * Tools require confirmation if they have no execute function AND are not server-executed.\n * @param tools - Record of tool name to tool definition\n * @returns Array of tool names that require confirmation\n *\n * @deprecated Use `needsApproval` on server-side tools instead.\n */\nexport function detectToolsRequiringConfirmation(\n  tools?: Record<string, AITool<unknown, unknown>>\n): string[] {\n  if (!tools) return [];\n\n  return Object.entries(tools)\n    .filter(([_name, tool]) => !tool.execute)\n    .map(([name]) => name);\n}\n\n/**\n * Return type for addToolOutput function\n */\ntype AddToolOutputOptions = {\n  /** The ID of the tool call to provide output for */\n  toolCallId: string;\n  /** The name of the tool (optional, for type safety) */\n  toolName?: string;\n  /** The output to provide */\n  output: unknown;\n};\n\nexport function useAgentChat<\n  State = unknown,\n  ChatMessage extends UIMessage = UIMessage\n>(\n  options: UseAgentChatOptions<State, ChatMessage>\n): Omit<ReturnType<typeof useChat<ChatMessage>>, \"addToolOutput\"> & {\n  clearHistory: () => void;\n  /**\n   * Provide output for a tool call. Use this for tools that require user interaction\n   * or client-side execution.\n   */\n  addToolOutput: (opts: AddToolOutputOptions) => void;\n} {\n  const {\n    agent,\n    getInitialMessages,\n    messages: optionsInitialMessages,\n    onToolCall,\n    experimental_automaticToolResolution,\n    tools,\n    toolsRequiringConfirmation: manualToolsRequiringConfirmation,\n    autoContinueAfterToolResult = false, // Opt-in to server auto-continuation\n    autoSendAfterAllConfirmationsResolved = true, // Legacy option for client-side batching\n    resume = true, // Enable stream resumption by default\n    prepareSendMessagesRequest,\n    ...rest\n  } = options;\n\n  // Auto-detect tools requiring confirmation, or use manual override\n  // @deprecated - this will be removed when toolsRequiringConfirmation is removed\n  const toolsRequiringConfirmation =\n    manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);\n\n  // Keep a ref to always point to the latest onToolCall callback\n  const onToolCallRef = useRef(onToolCall);\n  onToolCallRef.current = onToolCall;\n\n  const agentUrl = new URL(\n    `${\n      // @ts-expect-error we're using a protected _url property that includes query params\n      ((agent._url as string | null) || agent._pkurl)\n        ?.replace(\"ws://\", \"http://\")\n        .replace(\"wss://\", \"https://\")\n    }`\n  );\n\n  agentUrl.searchParams.delete(\"_pk\");\n  const agentUrlString = agentUrl.toString();\n\n  // we need to include agent.name in cache key to prevent collisions during agent switching.\n  // The URL may be stale between updateProperties() and reconnect(), but agent.name\n  // is updated synchronously, so each thread gets its own cache entry\n  const initialMessagesCacheKey = `${agentUrlString}|${agent.agent ?? \"\"}|${agent.name ?? \"\"}`;\n\n  // Keep a ref to always point to the latest agent instance\n  const agentRef = useRef(agent);\n  useEffect(() => {\n    agentRef.current = agent;\n  }, [agent]);\n\n  async function defaultGetInitialMessagesFetch({\n    url\n  }: GetInitialMessagesOptions) {\n    const getMessagesUrl = new URL(url);\n    getMessagesUrl.pathname += \"/get-messages\";\n    const response = await fetch(getMessagesUrl.toString(), {\n      credentials: options.credentials,\n      headers: options.headers\n    });\n\n    if (!response.ok) {\n      console.warn(\n        `Failed to fetch initial messages: ${response.status} ${response.statusText}`\n      );\n      return [];\n    }\n\n    const text = await response.text();\n    if (!text.trim()) {\n      return [];\n    }\n\n    try {\n      return JSON.parse(text) as ChatMessage[];\n    } catch (error) {\n      console.warn(\"Failed to parse initial messages JSON:\", error);\n      return [];\n    }\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions,\n    cacheKey: string\n  ) {\n    if (requestCache.has(cacheKey)) {\n      return requestCache.get(cacheKey)! as Promise<ChatMessage[]>;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    requestCache.set(cacheKey, promise);\n    return promise;\n  }\n\n  const initialMessagesPromise =\n    getInitialMessages === null\n      ? null\n      : doGetInitialMessages(\n          {\n            agent: agent.agent,\n            name: agent.name,\n            url: agentUrlString\n          },\n          initialMessagesCacheKey\n        );\n  const initialMessages = initialMessagesPromise\n    ? use(initialMessagesPromise)\n    : (optionsInitialMessages ?? []);\n\n  useEffect(() => {\n    if (!initialMessagesPromise) {\n      return;\n    }\n    requestCache.set(initialMessagesCacheKey, initialMessagesPromise!);\n    return () => {\n      if (\n        requestCache.get(initialMessagesCacheKey) === initialMessagesPromise\n      ) {\n        requestCache.delete(initialMessagesCacheKey);\n      }\n    };\n  }, [initialMessagesCacheKey, initialMessagesPromise]);\n\n  const aiFetch = useCallback(\n    async (request: RequestInfo | URL, options: RequestInit = {}) => {\n      const {\n        method,\n        keepalive,\n        headers,\n        body,\n        redirect,\n        integrity,\n        signal,\n        credentials,\n        mode,\n        referrer,\n        referrerPolicy,\n        window\n      } = options;\n      const id = nanoid(8);\n      const abortController = new AbortController();\n      let controller: ReadableStreamDefaultController;\n      const currentAgent = agentRef.current;\n\n      // Track this request ID so the onAgentMessage handler knows to skip it\n      // (this tab's aiFetch listener handles its own stream)\n      localRequestIdsRef.current.add(id);\n\n      signal?.addEventListener(\"abort\", () => {\n        currentAgent.send(\n          JSON.stringify({\n            id,\n            type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL\n          })\n        );\n\n        // NOTE - If we wanted to, we could preserve the \"interrupted\" message here, with the code below\n        //        However, I think it might be the responsibility of the library user to implement that behavior manually?\n        //        Reasoning: This code could be subject to collisions, as it \"force saves\" the messages we have locally\n        //\n        // agent.send(JSON.stringify({\n        //   type: MessageType.CF_AGENT_CHAT_MESSAGES,\n        //   messages: ... /* some way of getting current messages ref? */\n        // }))\n        abortController.abort();\n        // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)\n        try {\n          controller.close();\n        } catch {\n          // Stream may already be errored or closed\n        }\n        // Clean up the request ID tracking\n        localRequestIdsRef.current.delete(id);\n      });\n\n      currentAgent.addEventListener(\n        \"message\",\n        (event) => {\n          let data: OutgoingMessage<ChatMessage>;\n          try {\n            data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n          } catch (_error) {\n            // silently ignore invalid messages for now\n            // TODO: log errors with log levels\n            return;\n          }\n          if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {\n            if (data.id === id) {\n              if (data.error) {\n                controller.error(new Error(data.body));\n                abortController.abort();\n                // Clean up the request ID tracking\n                localRequestIdsRef.current.delete(id);\n              } else {\n                // Only enqueue non-empty data to prevent JSON parsing errors\n                if (data.body?.trim()) {\n                  controller.enqueue(\n                    new TextEncoder().encode(`data: ${data.body}\\n\\n`)\n                  );\n                }\n                if (data.done) {\n                  try {\n                    controller.close();\n                  } catch {\n                    // Stream may already be errored or closed\n                  }\n                  abortController.abort();\n                  // Clean up the request ID tracking\n                  localRequestIdsRef.current.delete(id);\n                }\n              }\n            }\n          }\n        },\n        { signal: abortController.signal }\n      );\n\n      const stream = new ReadableStream({\n        start(c) {\n          controller = c;\n        },\n        cancel(reason?: unknown) {\n          console.warn(\n            \"[@cloudflare/ai-chat/react] cancelling stream\",\n            id,\n            reason || \"no reason\"\n          );\n        }\n      });\n\n      currentAgent.send(\n        JSON.stringify({\n          id,\n          init: {\n            body,\n            credentials,\n            headers,\n            integrity,\n            keepalive,\n            method,\n            mode,\n            redirect,\n            referrer,\n            referrerPolicy,\n            window\n          },\n          type: MessageType.CF_AGENT_USE_CHAT_REQUEST,\n          url: request.toString()\n        })\n      );\n\n      return new Response(stream);\n    },\n    []\n  );\n\n  // Use synchronous ref updates to avoid race conditions between effect runs.\n  // This ensures the ref always has the latest value before any effect reads it.\n  const toolsRef = useRef(tools);\n  toolsRef.current = tools;\n\n  const prepareSendMessagesRequestRef = useRef(prepareSendMessagesRequest);\n  prepareSendMessagesRequestRef.current = prepareSendMessagesRequest;\n\n  const customTransport: ChatTransport<ChatMessage> = useMemo(\n    () => ({\n      sendMessages: async (\n        sendMessageOptions: Parameters<\n          typeof DefaultChatTransport.prototype.sendMessages\n        >[0]\n      ) => {\n        // Extract schemas from tools with execute functions\n        const clientToolSchemas = extractClientToolSchemas(toolsRef.current);\n\n        const combinedPrepare =\n          clientToolSchemas || prepareSendMessagesRequestRef.current\n            ? async (\n                prepareOptions: PrepareSendMessagesRequestOptions<ChatMessage>\n              ): Promise<InternalPrepareResult> => {\n                // Start with auto-extracted client tool schemas\n                let body: Record<string, unknown> = {};\n                let headers: HeadersInit | undefined;\n                let credentials: RequestCredentials | undefined;\n                let api: string | undefined;\n\n                if (clientToolSchemas) {\n                  body = {\n                    id: prepareOptions.id,\n                    messages: prepareOptions.messages,\n                    trigger: prepareOptions.trigger,\n                    clientTools: clientToolSchemas\n                  };\n                }\n\n                // Apply prepareSendMessagesRequest callback for additional customization\n                if (prepareSendMessagesRequestRef.current) {\n                  const userResult =\n                    await prepareSendMessagesRequestRef.current(prepareOptions);\n\n                  // user's callback can override or extend\n                  headers = userResult.headers;\n                  credentials = userResult.credentials;\n                  api = userResult.api;\n                  body = {\n                    ...body,\n                    ...(userResult.body ?? {})\n                  };\n                }\n\n                return { body, headers, credentials, api };\n              }\n            : undefined;\n\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch,\n          prepareSendMessagesRequest: combinedPrepare\n        });\n        return transport.sendMessages(sendMessageOptions);\n      },\n      reconnectToStream: async () => null\n    }),\n    [agentUrlString, aiFetch]\n  );\n\n  const useChatHelpers = useChat<ChatMessage>({\n    ...rest,\n    messages: initialMessages,\n    transport: customTransport,\n    id: agent._pk\n    // Note: We handle stream resumption via WebSocket instead of HTTP,\n    // so we don't pass 'resume' to useChat. The onStreamResuming handler\n    // automatically resumes active streams when the WebSocket reconnects.\n  });\n\n  const processedToolCalls = useRef(new Set<string>());\n  const isResolvingToolsRef = useRef(false);\n  // Counter to force the tool resolution effect to re-run after completing\n  // a batch of tool calls. Without this, if new tool calls arrive while\n  // isResolvingToolsRef is true (e.g. server auto-continuation), the effect\n  // exits early and never retriggers because the ref reset doesn't cause\n  // a re-render.\n  const [toolResolutionTrigger, setToolResolutionTrigger] = useState(0);\n\n  // Fix for issue #728: Track client-side tool results in local state\n  // to ensure tool parts show output-available immediately after execution.\n  const [clientToolResults, setClientToolResults] = useState<\n    Map<string, unknown>\n  >(new Map());\n\n  // Ref to access current messages in callbacks without stale closures\n  const messagesRef = useRef(useChatHelpers.messages);\n  messagesRef.current = useChatHelpers.messages;\n\n  // Calculate pending confirmations for the latest assistant message\n  const lastMessage =\n    useChatHelpers.messages[useChatHelpers.messages.length - 1];\n\n  const pendingConfirmations = (() => {\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return { messageId: undefined, toolCallIds: new Set<string>() };\n    }\n\n    const pendingIds = new Set<string>();\n    for (const part of lastMessage.parts ?? []) {\n      if (\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        toolsRequiringConfirmation.includes(getToolName(part))\n      ) {\n        pendingIds.add(part.toolCallId);\n      }\n    }\n    return { messageId: lastMessage.id, toolCallIds: pendingIds };\n  })();\n\n  const pendingConfirmationsRef = useRef(pendingConfirmations);\n  pendingConfirmationsRef.current = pendingConfirmations;\n\n  // Automatic tool resolution effect.\n  useEffect(() => {\n    if (!experimental_automaticToolResolution) {\n      return;\n    }\n\n    // Prevent re-entry while async operations are in progress\n    if (isResolvingToolsRef.current) {\n      return;\n    }\n\n    const lastMessage =\n      useChatHelpers.messages[useChatHelpers.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return;\n    }\n\n    const toolCalls = lastMessage.parts.filter(\n      (part) =>\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        !processedToolCalls.current.has(part.toolCallId)\n    );\n\n    if (toolCalls.length > 0) {\n      // Capture tools synchronously before async work\n      const currentTools = toolsRef.current;\n      const toolCallsToResolve = toolCalls.filter(\n        (part) =>\n          isToolUIPart(part) &&\n          !toolsRequiringConfirmation.includes(getToolName(part)) &&\n          currentTools?.[getToolName(part)]?.execute\n      );\n\n      if (toolCallsToResolve.length > 0) {\n        isResolvingToolsRef.current = true;\n\n        (async () => {\n          try {\n            const toolResults: Array<{\n              toolCallId: string;\n              toolName: string;\n              output: unknown;\n            }> = [];\n\n            for (const part of toolCallsToResolve) {\n              if (isToolUIPart(part)) {\n                let toolOutput: unknown = null;\n                const toolName = getToolName(part);\n                const tool = currentTools?.[toolName];\n\n                if (tool?.execute && part.input !== undefined) {\n                  try {\n                    toolOutput = await tool.execute(part.input);\n                  } catch (error) {\n                    toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;\n                  }\n                }\n\n                processedToolCalls.current.add(part.toolCallId);\n\n                toolResults.push({\n                  toolCallId: part.toolCallId,\n                  toolName,\n                  output: toolOutput\n                });\n              }\n            }\n\n            if (toolResults.length > 0) {\n              // Send tool results to server first (server is source of truth)\n              for (const result of toolResults) {\n                agentRef.current.send(\n                  JSON.stringify({\n                    type: MessageType.CF_AGENT_TOOL_RESULT,\n                    toolCallId: result.toolCallId,\n                    toolName: result.toolName,\n                    output: result.output,\n                    autoContinue: autoContinueAfterToolResult\n                  })\n                );\n              }\n\n              // Also update local state via AI SDK for immediate UI feedback\n              await Promise.all(\n                toolResults.map((result) =>\n                  useChatHelpers.addToolResult({\n                    tool: result.toolName,\n                    toolCallId: result.toolCallId,\n                    output: result.output\n                  })\n                )\n              );\n\n              setClientToolResults((prev) => {\n                const newMap = new Map(prev);\n                for (const result of toolResults) {\n                  newMap.set(result.toolCallId, result.output);\n                }\n                return newMap;\n              });\n            }\n\n            // Note: We don't call sendMessage() here anymore.\n            // The server will continue the conversation after applying tool results.\n          } finally {\n            isResolvingToolsRef.current = false;\n            // Trigger a re-run so any tool calls that arrived while we were\n            // busy (e.g. from server auto-continuation) get picked up.\n            setToolResolutionTrigger((c) => c + 1);\n          }\n        })();\n      }\n    }\n  }, [\n    useChatHelpers.messages,\n    experimental_automaticToolResolution,\n    useChatHelpers.addToolResult,\n    toolsRequiringConfirmation,\n    autoContinueAfterToolResult,\n    toolResolutionTrigger\n  ]);\n\n  // Helper function to send tool output to server\n  const sendToolOutputToServer = useCallback(\n    (toolCallId: string, toolName: string, output: unknown) => {\n      agentRef.current.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_TOOL_RESULT,\n          toolCallId,\n          toolName,\n          output,\n          autoContinue: autoContinueAfterToolResult\n        })\n      );\n\n      setClientToolResults((prev) => new Map(prev).set(toolCallId, output));\n    },\n    [autoContinueAfterToolResult]\n  );\n\n  // Helper function to send tool approval to server\n  const sendToolApprovalToServer = useCallback(\n    (toolCallId: string, approved: boolean) => {\n      agentRef.current.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_TOOL_APPROVAL,\n          toolCallId,\n          approved\n        })\n      );\n    },\n    []\n  );\n\n  // Effect for new onToolCall callback pattern (v6 style)\n  // This fires when there are tool calls that need client-side handling\n  useEffect(() => {\n    const currentOnToolCall = onToolCallRef.current;\n    if (!currentOnToolCall) {\n      return;\n    }\n\n    const lastMessage =\n      useChatHelpers.messages[useChatHelpers.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return;\n    }\n\n    // Find tool calls in input-available state that haven't been processed\n    const pendingToolCalls = lastMessage.parts.filter(\n      (part) =>\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        !processedToolCalls.current.has(part.toolCallId)\n    );\n\n    for (const part of pendingToolCalls) {\n      if (isToolUIPart(part)) {\n        const toolCallId = part.toolCallId;\n        const toolName = getToolName(part);\n\n        // Mark as processed to prevent re-triggering\n        processedToolCalls.current.add(toolCallId);\n\n        // Create addToolOutput function for this specific tool call\n        const addToolOutput = (opts: {\n          toolCallId: string;\n          output: unknown;\n        }) => {\n          sendToolOutputToServer(opts.toolCallId, toolName, opts.output);\n\n          // Update local state via AI SDK\n          useChatHelpers.addToolResult({\n            tool: toolName,\n            toolCallId: opts.toolCallId,\n            output: opts.output\n          });\n        };\n\n        // Call the onToolCall callback\n        // The callback is responsible for calling addToolOutput when ready\n        currentOnToolCall({\n          toolCall: {\n            toolCallId,\n            toolName,\n            input: part.input\n          },\n          addToolOutput\n        });\n      }\n    }\n  }, [\n    useChatHelpers.messages,\n    sendToolOutputToServer,\n    useChatHelpers.addToolResult\n  ]);\n\n  /**\n   * Contains the request ID, accumulated message parts, and a unique message ID.\n   * Used for both resumed streams and real-time broadcasts from other tabs.\n   */\n  const activeStreamRef = useRef<{\n    id: string;\n    messageId: string;\n    parts: ChatMessage[\"parts\"];\n  } | null>(null);\n\n  /**\n   * Tracks request IDs initiated by this tab via aiFetch.\n   * Used to distinguish local requests from broadcasts.\n   */\n  const localRequestIdsRef = useRef<Set<string>>(new Set());\n\n  useEffect(() => {\n    /**\n     * Unified message handler that parses JSON once and dispatches based on type.\n     * Avoids duplicate parsing overhead from separate listeners.\n     */\n    function onAgentMessage(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n\n      let data: OutgoingMessage<ChatMessage>;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n      } catch (_error) {\n        return;\n      }\n\n      switch (data.type) {\n        case MessageType.CF_AGENT_CHAT_CLEAR:\n          useChatHelpers.setMessages([]);\n          break;\n\n        case MessageType.CF_AGENT_CHAT_MESSAGES:\n          useChatHelpers.setMessages(data.messages);\n          break;\n\n        case MessageType.CF_AGENT_MESSAGE_UPDATED:\n          // Server updated a message (e.g., applied tool result)\n          // Update the specific message in local state\n          useChatHelpers.setMessages((prevMessages: ChatMessage[]) => {\n            const updatedMessage = data.message;\n\n            // First try to find by message ID\n            let idx = prevMessages.findIndex((m) => m.id === updatedMessage.id);\n\n            // If not found by ID, try to find by toolCallId\n            // This handles the case where client has AI SDK-generated IDs\n            // but server has server-generated IDs\n            if (idx < 0) {\n              const updatedToolCallIds = new Set(\n                updatedMessage.parts\n                  .filter(\n                    (p: ChatMessage[\"parts\"][number]) =>\n                      \"toolCallId\" in p && p.toolCallId\n                  )\n                  .map(\n                    (p: ChatMessage[\"parts\"][number]) =>\n                      (p as { toolCallId: string }).toolCallId\n                  )\n              );\n\n              if (updatedToolCallIds.size > 0) {\n                idx = prevMessages.findIndex((m) =>\n                  m.parts.some(\n                    (p) =>\n                      \"toolCallId\" in p &&\n                      updatedToolCallIds.has(\n                        (p as { toolCallId: string }).toolCallId\n                      )\n                  )\n                );\n              }\n            }\n\n            if (idx >= 0) {\n              const updated = [...prevMessages];\n              // Preserve the client's message ID but update the content\n              updated[idx] = {\n                ...updatedMessage,\n                id: prevMessages[idx].id\n              };\n              return updated;\n            }\n            // Message not found, append it\n            return [...prevMessages, updatedMessage];\n          });\n          break;\n\n        case MessageType.CF_AGENT_STREAM_RESUMING:\n          if (!resume) return;\n          // Clear any previous incomplete active stream to prevent memory leak\n          activeStreamRef.current = null;\n          // Initialize active stream state with unique ID\n          activeStreamRef.current = {\n            id: data.id,\n            messageId: nanoid(),\n            parts: []\n          };\n          // Send ACK to server - we're ready to receive chunks\n          agentRef.current.send(\n            JSON.stringify({\n              type: MessageType.CF_AGENT_STREAM_RESUME_ACK,\n              id: data.id\n            })\n          );\n          break;\n\n        case MessageType.CF_AGENT_USE_CHAT_RESPONSE: {\n          // Skip if this is a response to a request this tab initiated\n          // (handled by the aiFetch listener instead)\n          if (localRequestIdsRef.current.has(data.id)) return;\n\n          // For continuations, find the last assistant message ID to append to\n          const isContinuation = data.continuation === true;\n\n          // Initialize stream state for broadcasts from other tabs\n          if (\n            !activeStreamRef.current ||\n            activeStreamRef.current.id !== data.id\n          ) {\n            let messageId = nanoid();\n            let existingParts: ChatMessage[\"parts\"] = [];\n\n            // For continuations, use the last assistant message's ID and parts\n            if (isContinuation) {\n              const currentMessages = messagesRef.current;\n              for (let i = currentMessages.length - 1; i >= 0; i--) {\n                if (currentMessages[i].role === \"assistant\") {\n                  messageId = currentMessages[i].id;\n                  existingParts = [...currentMessages[i].parts];\n                  break;\n                }\n              }\n            }\n\n            activeStreamRef.current = {\n              id: data.id,\n              messageId,\n              parts: existingParts\n            };\n          }\n\n          const activeMsg = activeStreamRef.current;\n\n          if (data.body?.trim()) {\n            try {\n              const chunkData = JSON.parse(data.body);\n\n              // Handle all chunk types for complete message reconstruction\n              switch (chunkData.type) {\n                case \"text-start\": {\n                  activeMsg.parts.push({\n                    type: \"text\",\n                    text: \"\",\n                    state: \"streaming\"\n                  });\n                  break;\n                }\n                case \"text-delta\": {\n                  const lastTextPart = [...activeMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"text\");\n                  if (lastTextPart && lastTextPart.type === \"text\") {\n                    lastTextPart.text += chunkData.delta;\n                  } else {\n                    // Handle plain text responses (no text-start)\n                    activeMsg.parts.push({\n                      type: \"text\",\n                      text: chunkData.delta\n                    });\n                  }\n                  break;\n                }\n                case \"text-end\": {\n                  const lastTextPart = [...activeMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"text\");\n                  if (lastTextPart && \"state\" in lastTextPart) {\n                    lastTextPart.state = \"done\";\n                  }\n                  break;\n                }\n                case \"reasoning-start\": {\n                  activeMsg.parts.push({\n                    type: \"reasoning\",\n                    text: \"\",\n                    state: \"streaming\"\n                  });\n                  break;\n                }\n                case \"reasoning-delta\": {\n                  const lastReasoningPart = [...activeMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"reasoning\");\n                  if (\n                    lastReasoningPart &&\n                    lastReasoningPart.type === \"reasoning\"\n                  ) {\n                    lastReasoningPart.text += chunkData.delta;\n                  }\n                  break;\n                }\n                case \"reasoning-end\": {\n                  const lastReasoningPart = [...activeMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"reasoning\");\n                  if (lastReasoningPart && \"state\" in lastReasoningPart) {\n                    lastReasoningPart.state = \"done\";\n                  }\n                  break;\n                }\n                case \"file\": {\n                  activeMsg.parts.push({\n                    type: \"file\",\n                    mediaType: chunkData.mediaType,\n                    url: chunkData.url\n                  });\n                  break;\n                }\n                case \"source-url\": {\n                  activeMsg.parts.push({\n                    type: \"source-url\",\n                    sourceId: chunkData.sourceId,\n                    url: chunkData.url,\n                    title: chunkData.title\n                  });\n                  break;\n                }\n                case \"source-document\": {\n                  activeMsg.parts.push({\n                    type: \"source-document\",\n                    sourceId: chunkData.sourceId,\n                    mediaType: chunkData.mediaType,\n                    title: chunkData.title,\n                    filename: chunkData.filename\n                  });\n                  break;\n                }\n                case \"tool-input-available\": {\n                  // Add tool call part when input is available\n                  activeMsg.parts.push({\n                    type: `tool-${chunkData.toolName}`,\n                    toolCallId: chunkData.toolCallId,\n                    toolName: chunkData.toolName,\n                    state: \"input-available\",\n                    input: chunkData.input\n                  } as ChatMessage[\"parts\"][number]);\n                  break;\n                }\n                case \"tool-output-available\": {\n                  // Update existing tool part with output using immutable pattern\n                  activeMsg.parts = activeMsg.parts.map((p) => {\n                    if (\n                      \"toolCallId\" in p &&\n                      p.toolCallId === chunkData.toolCallId &&\n                      \"state\" in p\n                    ) {\n                      return {\n                        ...p,\n                        state: \"output-available\",\n                        output: chunkData.output\n                      } as ChatMessage[\"parts\"][number];\n                    }\n                    return p;\n                  });\n                  break;\n                }\n                case \"step-start\": {\n                  activeMsg.parts.push({ type: \"step-start\" });\n                  break;\n                }\n                // Other chunk types (tool-input-start, tool-input-delta, etc.)\n                // are intermediate states - the final state will be captured above\n              }\n\n              // Update messages with the partial response\n              useChatHelpers.setMessages((prevMessages: ChatMessage[]) => {\n                if (!activeMsg) return prevMessages;\n\n                const existingIdx = prevMessages.findIndex(\n                  (m) => m.id === activeMsg.messageId\n                );\n\n                const partialMessage = {\n                  id: activeMsg.messageId,\n                  role: \"assistant\" as const,\n                  parts: [...activeMsg.parts]\n                } as unknown as ChatMessage;\n\n                if (existingIdx >= 0) {\n                  const updated = [...prevMessages];\n                  updated[existingIdx] = partialMessage;\n                  return updated;\n                }\n                return [...prevMessages, partialMessage];\n              });\n            } catch (parseError) {\n              // Log corrupted chunk for debugging - could indicate data loss\n              console.warn(\n                \"[useAgentChat] Failed to parse stream chunk:\",\n                parseError instanceof Error ? parseError.message : parseError,\n                \"body:\",\n                data.body?.slice(0, 100) // Truncate for logging\n              );\n            }\n          }\n\n          // Clear on completion or error\n          if (data.done || data.error) {\n            activeStreamRef.current = null;\n          }\n          break;\n        }\n      }\n    }\n\n    agent.addEventListener(\"message\", onAgentMessage);\n    return () => {\n      agent.removeEventListener(\"message\", onAgentMessage);\n      // Clear active stream state on cleanup to prevent memory leak\n      activeStreamRef.current = null;\n    };\n  }, [agent, useChatHelpers.setMessages, resume]);\n\n  // Wrapper that sends tool result to server and optionally continues conversation.\n  const addToolResultAndSendMessage: typeof useChatHelpers.addToolResult =\n    async (args) => {\n      const { toolCallId } = args;\n      const toolName = \"tool\" in args ? args.tool : \"\";\n      const output = \"output\" in args ? args.output : undefined;\n\n      // Send tool result to server (server is source of truth)\n      // Include flag to tell server whether to auto-continue\n      agentRef.current.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_TOOL_RESULT,\n          toolCallId,\n          toolName,\n          output,\n          autoContinue: autoContinueAfterToolResult\n        })\n      );\n\n      setClientToolResults((prev) => new Map(prev).set(toolCallId, output));\n\n      // Call AI SDK's addToolResult for local state update (non-blocking)\n      // We don't await this since clientToolResults provides immediate UI feedback\n      useChatHelpers.addToolResult(args);\n\n      // If server auto-continuation is disabled, client needs to trigger continuation\n      if (!autoContinueAfterToolResult) {\n        // Use legacy behavior: batch confirmations or send immediately\n        if (!autoSendAfterAllConfirmationsResolved) {\n          // Always send immediately\n          useChatHelpers.sendMessage();\n          return;\n        }\n\n        // Wait for all confirmations before sending\n        const pending = pendingConfirmationsRef.current?.toolCallIds;\n        if (!pending) {\n          useChatHelpers.sendMessage();\n          return;\n        }\n\n        const wasLast = pending.size === 1 && pending.has(toolCallId);\n        if (pending.has(toolCallId)) {\n          pending.delete(toolCallId);\n        }\n\n        if (wasLast || pending.size === 0) {\n          useChatHelpers.sendMessage();\n        }\n      }\n      // If autoContinueAfterToolResult is true, server handles continuation\n    };\n\n  // Wrapper that sends tool approval to server before updating local state.\n  // This prevents duplicate messages by ensuring server updates the message\n  // in place with the existing ID, rather than relying on ID resolution\n  // when sendMessage() is called later.\n  const addToolApprovalResponseAndNotifyServer: typeof useChatHelpers.addToolApprovalResponse =\n    (args) => {\n      const { id: approvalId, approved } = args;\n\n      // Find the toolCallId from the approval ID\n      // The approval ID is stored on the tool part's approval.id field\n      let toolCallId: string | undefined;\n      for (const msg of messagesRef.current) {\n        for (const part of msg.parts) {\n          if (\n            \"toolCallId\" in part &&\n            \"approval\" in part &&\n            (part.approval as { id?: string })?.id === approvalId\n          ) {\n            toolCallId = part.toolCallId as string;\n            break;\n          }\n        }\n        if (toolCallId) break;\n      }\n\n      if (toolCallId) {\n        // Send approval to server first (server updates message in place)\n        sendToolApprovalToServer(toolCallId, approved);\n      } else {\n        console.warn(\n          `[useAgentChat] addToolApprovalResponse: Could not find toolCallId for approval ID \"${approvalId}\". ` +\n            \"Server will not be notified, which may cause duplicate messages.\"\n        );\n      }\n\n      // Call AI SDK's addToolApprovalResponse for local state update\n      useChatHelpers.addToolApprovalResponse(args);\n    };\n\n  // Fix for issue #728: Merge client-side tool results with messages\n  // so tool parts show output-available immediately after execution\n  const messagesWithToolResults = useMemo(() => {\n    if (clientToolResults.size === 0) {\n      return useChatHelpers.messages;\n    }\n    return useChatHelpers.messages.map((msg) => ({\n      ...msg,\n      parts: msg.parts.map((p) => {\n        if (\n          !(\"toolCallId\" in p) ||\n          !(\"state\" in p) ||\n          p.state !== \"input-available\" ||\n          !clientToolResults.has(p.toolCallId)\n        ) {\n          return p;\n        }\n        return {\n          ...p,\n          state: \"output-available\" as const,\n          output: clientToolResults.get(p.toolCallId)\n        };\n      })\n    })) as ChatMessage[];\n  }, [useChatHelpers.messages, clientToolResults]);\n\n  // Cleanup stale entries from clientToolResults when messages change\n  // to prevent memory leak in long conversations.\n  // Note: We intentionally exclude clientToolResults from deps to avoid infinite loops.\n  // The functional update form gives us access to the previous state.\n  useEffect(() => {\n    // Collect all current toolCallIds from messages\n    const currentToolCallIds = new Set<string>();\n    for (const msg of useChatHelpers.messages) {\n      for (const part of msg.parts) {\n        if (\"toolCallId\" in part && part.toolCallId) {\n          currentToolCallIds.add(part.toolCallId);\n        }\n      }\n    }\n\n    // Use functional update to check and clean stale entries atomically\n    setClientToolResults((prev) => {\n      if (prev.size === 0) return prev;\n\n      // Check if any entries are stale\n      let hasStaleEntries = false;\n      for (const toolCallId of prev.keys()) {\n        if (!currentToolCallIds.has(toolCallId)) {\n          hasStaleEntries = true;\n          break;\n        }\n      }\n\n      // Only create new Map if there are stale entries to remove\n      if (!hasStaleEntries) return prev;\n\n      const newMap = new Map<string, unknown>();\n      for (const [id, output] of prev) {\n        if (currentToolCallIds.has(id)) {\n          newMap.set(id, output);\n        }\n      }\n      return newMap;\n    });\n\n    // Also cleanup processedToolCalls to prevent issues in long conversations\n    for (const toolCallId of processedToolCalls.current) {\n      if (!currentToolCallIds.has(toolCallId)) {\n        processedToolCalls.current.delete(toolCallId);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [useChatHelpers.messages]);\n\n  // Create addToolOutput function for external use\n  const addToolOutput = useCallback(\n    (opts: { toolCallId: string; toolName?: string; output: unknown }) => {\n      const toolName = opts.toolName ?? \"\";\n      sendToolOutputToServer(opts.toolCallId, toolName, opts.output);\n\n      // Update local state via AI SDK\n      useChatHelpers.addToolResult({\n        tool: toolName,\n        toolCallId: opts.toolCallId,\n        output: opts.output\n      });\n    },\n    [sendToolOutputToServer, useChatHelpers.addToolResult]\n  );\n\n  return {\n    ...useChatHelpers,\n    messages: messagesWithToolResults,\n    /**\n     * Provide output for a tool call. Use this for tools that require user interaction\n     * or client-side execution.\n     */\n    addToolOutput,\n    /**\n     * @deprecated Use `addToolOutput` instead.\n     */\n    addToolResult: addToolResultAndSendMessage,\n    /**\n     * Respond to a tool approval request. Use this for tools with `needsApproval`.\n     * This wrapper notifies the server before updating local state, preventing\n     * duplicate messages when sendMessage() is called afterward.\n     */\n    addToolApprovalResponse: addToolApprovalResponseAndNotifyServer,\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      setClientToolResults(new Map());\n      processedToolCalls.current.clear();\n      agent.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_CHAT_CLEAR\n        })\n      );\n    },\n    setMessages: (\n      messages: Parameters<typeof useChatHelpers.setMessages>[0]\n    ) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          messages: Array.isArray(messages) ? messages : [],\n          type: MessageType.CF_AGENT_CHAT_MESSAGES\n        })\n      );\n    }\n  };\n}\n"],"mappings":"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"}