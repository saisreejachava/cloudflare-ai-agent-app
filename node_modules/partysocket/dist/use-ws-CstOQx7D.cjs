const require_ws = require("./ws-COtplmrw.cjs");
let react = require("react");

//#region src/use-handlers.ts
/** Attaches event handlers to a WebSocket in a React Lifecycle-friendly way */
const useAttachWebSocketEventHandlers = (socket, options) => {
  const handlersRef = (0, react.useRef)(options);
  handlersRef.current = options;
  (0, react.useEffect)(() => {
    const onOpen = (event) => handlersRef.current?.onOpen?.(event);
    const onMessage = (event) => handlersRef.current?.onMessage?.(event);
    const onClose = (event) => handlersRef.current?.onClose?.(event);
    const onError = (event) => handlersRef.current?.onError?.(event);
    socket.addEventListener("open", onOpen);
    socket.addEventListener("close", onClose);
    socket.addEventListener("error", onError);
    socket.addEventListener("message", onMessage);
    return () => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("close", onClose);
      socket.removeEventListener("error", onError);
      socket.removeEventListener("message", onMessage);
    };
  }, [socket]);
};

//#endregion
//#region src/use-socket.ts
/** When any of the option values are changed, we should reinitialize the socket */
const getOptionsThatShouldCauseRestartWhenChanged = (options) => [
  options.startClosed,
  options.minUptime,
  options.maxRetries,
  options.connectionTimeout,
  options.maxEnqueuedMessages,
  options.maxReconnectionDelay,
  options.minReconnectionDelay,
  options.reconnectionDelayGrowFactor,
  options.debug
];
/**
 * Initializes a PartySocket (or WebSocket) and keeps it stable across renders,
 * but reconnects and updates the reference when any of the connection args change.
 */
function useStableSocket({
  options,
  createSocket,
  createSocketMemoKey: createOptionsMemoKey
}) {
  const { enabled = true } = options;
  const socketOptions = (0, react.useMemo)(() => {
    return options;
  }, [createOptionsMemoKey(options)]);
  const [socket, setSocket] = (0, react.useState)(() =>
    createSocket({
      ...socketOptions,
      startClosed: true
    })
  );
  const socketInitializedRef = (0, react.useRef)(null);
  const createSocketRef = (0, react.useRef)(createSocket);
  createSocketRef.current = createSocket;
  const prevEnabledRef = (0, react.useRef)(enabled);
  (0, react.useEffect)(() => {
    if (!enabled) {
      socket.close();
      prevEnabledRef.current = enabled;
      return;
    }
    if (!prevEnabledRef.current && enabled) {
      socket.reconnect();
      prevEnabledRef.current = enabled;
      return;
    }
    prevEnabledRef.current = enabled;
    if (socketInitializedRef.current === socket)
      setSocket(
        createSocketRef.current({
          ...socketOptions,
          startClosed: false
        })
      );
    else {
      if (!socketInitializedRef.current && socketOptions.startClosed !== true)
        socket.reconnect();
      socketInitializedRef.current = socket;
      return () => {
        socket.close();
      };
    }
  }, [socket, socketOptions, enabled]);
  return socket;
}

//#endregion
//#region src/use-ws.ts
function useWebSocket(url, protocols, options = {}) {
  const socket = useStableSocket({
    options,
    createSocket: (options$1) =>
      new require_ws.ReconnectingWebSocket(url, protocols, options$1),
    createSocketMemoKey: (options$1) =>
      JSON.stringify([
        url,
        protocols,
        ...getOptionsThatShouldCauseRestartWhenChanged(options$1)
      ])
  });
  useAttachWebSocketEventHandlers(socket, options);
  return socket;
}

//#endregion
Object.defineProperty(exports, "getOptionsThatShouldCauseRestartWhenChanged", {
  enumerable: true,
  get: function () {
    return getOptionsThatShouldCauseRestartWhenChanged;
  }
});
Object.defineProperty(exports, "useAttachWebSocketEventHandlers", {
  enumerable: true,
  get: function () {
    return useAttachWebSocketEventHandlers;
  }
});
Object.defineProperty(exports, "useStableSocket", {
  enumerable: true,
  get: function () {
    return useStableSocket;
  }
});
Object.defineProperty(exports, "useWebSocket", {
  enumerable: true,
  get: function () {
    return useWebSocket;
  }
});
//# sourceMappingURL=use-ws-CstOQx7D.cjs.map
