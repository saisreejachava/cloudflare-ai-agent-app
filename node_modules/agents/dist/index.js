import { MessageType } from "./types.js";
import { camelCaseToKebabCase } from "./utils.js";
import { createHeaderBasedEmailResolver, signAgentHeaders } from "./email.js";
import { __DO_NOT_USE_WILL_BREAK__agentContext } from "./internal_context.js";
import { i as DisposableStore, n as MCPConnectionState } from "./client-connection-CGMuV62J.js";
import { DurableObjectOAuthClientProvider } from "./mcp/do-oauth-client-provider.js";
import { MCPClientManager } from "./mcp/client.js";
import { genericObservability } from "./observability/index.js";
import { parseCronExpression } from "cron-schedule";
import { nanoid } from "nanoid";
import { EmailMessage } from "cloudflare:email";
import { Server, getServerByName, routePartykitRequest } from "partyserver";

//#region src/index.ts
/**
* Type guard for RPC request messages
*/
function isRPCRequest(msg) {
	return typeof msg === "object" && msg !== null && "type" in msg && msg.type === MessageType.RPC && "id" in msg && typeof msg.id === "string" && "method" in msg && typeof msg.method === "string" && "args" in msg && Array.isArray(msg.args);
}
/**
* Type guard for state update messages
*/
function isStateUpdateMessage(msg) {
	return typeof msg === "object" && msg !== null && "type" in msg && msg.type === MessageType.CF_AGENT_STATE && "state" in msg;
}
const callableMetadata = /* @__PURE__ */ new WeakMap();
/**
* Error class for SQL execution failures, containing the query that failed
*/
var SqlError = class extends Error {
	constructor(query, cause) {
		const message = cause instanceof Error ? cause.message : String(cause);
		super(`SQL query failed: ${message}`, { cause });
		this.name = "SqlError";
		this.query = query;
	}
};
/**
* Decorator that marks a method as callable by clients
* @param metadata Optional metadata about the callable method
*/
function callable(metadata = {}) {
	return function callableDecorator(target, _context) {
		if (!callableMetadata.has(target)) callableMetadata.set(target, metadata);
		return target;
	};
}
let didWarnAboutUnstableCallable = false;
/**
* Decorator that marks a method as callable by clients
* @deprecated this has been renamed to callable, and unstable_callable will be removed in the next major version
* @param metadata Optional metadata about the callable method
*/
const unstable_callable = (metadata = {}) => {
	if (!didWarnAboutUnstableCallable) {
		didWarnAboutUnstableCallable = true;
		console.warn("unstable_callable is deprecated, use callable instead. unstable_callable will be removed in the next major version.");
	}
	return callable(metadata);
};
function getNextCronTime(cron) {
	return parseCronExpression(cron).getNextDate();
}
const STATE_ROW_ID = "cf_state_row_id";
const STATE_WAS_CHANGED = "cf_state_was_changed";
const DEFAULT_STATE = {};
/**
* Internal key used to store the readonly flag in connection state.
* Prefixed with _cf_ to avoid collision with user state keys.
*/
const CF_READONLY_KEY = "_cf_readonly";
/**
* Tracks which agent constructors have already emitted the onStateUpdate
* deprecation warning, so it fires at most once per class.
*/
const _onStateUpdateWarnedClasses = /* @__PURE__ */ new WeakSet();
/**
* Default options for Agent configuration.
* Child classes can override specific options without spreading.
*/
const DEFAULT_AGENT_STATIC_OPTIONS = {
	hibernate: true,
	sendIdentityOnConnect: true,
	hungScheduleTimeoutSeconds: 30
};
function getCurrentAgent() {
	const store = __DO_NOT_USE_WILL_BREAK__agentContext.getStore();
	if (!store) return {
		agent: void 0,
		connection: void 0,
		request: void 0,
		email: void 0
	};
	return store;
}
/**
* Wraps a method to run within the agent context, ensuring getCurrentAgent() works properly
* @param agent The agent instance
* @param method The method to wrap
* @returns A wrapped method that runs within the agent context
*/
function withAgentContext(method) {
	return function(...args) {
		const { connection, request, email, agent } = getCurrentAgent();
		if (agent === this) return method.apply(this, args);
		return __DO_NOT_USE_WILL_BREAK__agentContext.run({
			agent: this,
			connection,
			request,
			email
		}, () => {
			return method.apply(this, args);
		});
	};
}
/**
* Base class for creating Agent implementations
* @template Env Environment type containing bindings
* @template State State type to store within the Agent
*/
var Agent = class Agent extends Server {
	/**
	* Current state of the Agent
	*/
	get state() {
		if (this._state !== DEFAULT_STATE) return this._state;
		const wasChanged = this.sql`
        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}
      `;
		const result = this.sql`
      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
    `;
		if (wasChanged[0]?.state === "true" || result[0]?.state) {
			const state = result[0]?.state;
			try {
				this._state = JSON.parse(state);
			} catch (e) {
				console.error("Failed to parse stored state, falling back to initialState:", e);
				if (this.initialState !== DEFAULT_STATE) {
					this._state = this.initialState;
					this._setStateInternal(this.initialState);
				} else {
					this.sql`DELETE FROM cf_agents_state WHERE id = ${STATE_ROW_ID}`;
					this.sql`DELETE FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}`;
					return;
				}
			}
			return this._state;
		}
		if (this.initialState === DEFAULT_STATE) return;
		this._setStateInternal(this.initialState);
		return this.initialState;
	}
	static {
		this.options = { hibernate: true };
	}
	/**
	* Resolved options (merges defaults with subclass overrides)
	*/
	get _resolvedOptions() {
		const ctor = this.constructor;
		return {
			hibernate: ctor.options?.hibernate ?? DEFAULT_AGENT_STATIC_OPTIONS.hibernate,
			sendIdentityOnConnect: ctor.options?.sendIdentityOnConnect ?? DEFAULT_AGENT_STATIC_OPTIONS.sendIdentityOnConnect,
			hungScheduleTimeoutSeconds: ctor.options?.hungScheduleTimeoutSeconds ?? DEFAULT_AGENT_STATIC_OPTIONS.hungScheduleTimeoutSeconds
		};
	}
	/**
	* Execute SQL queries against the Agent's database
	* @template T Type of the returned rows
	* @param strings SQL query template strings
	* @param values Values to be inserted into the query
	* @returns Array of query results
	*/
	sql(strings, ...values) {
		let query = "";
		try {
			query = strings.reduce((acc, str, i) => acc + str + (i < values.length ? "?" : ""), "");
			return [...this.ctx.storage.sql.exec(query, ...values)];
		} catch (e) {
			throw this.onError(new SqlError(query, e));
		}
	}
	constructor(ctx, env) {
		super(ctx, env);
		this._state = DEFAULT_STATE;
		this._disposables = new DisposableStore();
		this._destroyed = false;
		this._rawStateAccessors = /* @__PURE__ */ new WeakMap();
		this._persistenceHookMode = "none";
		this._ParentClass = Object.getPrototypeOf(this).constructor;
		this.initialState = DEFAULT_STATE;
		this.observability = genericObservability;
		this._flushingQueue = false;
		this.alarm = async () => {
			const now = Math.floor(Date.now() / 1e3);
			const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE time <= ${now}
    `;
			if (result && Array.isArray(result)) for (const row of result) {
				const callback = this[row.callback];
				if (!callback) {
					console.error(`callback ${row.callback} not found`);
					continue;
				}
				if (row.type === "interval" && row.running === 1) {
					const executionStartedAt = row.execution_started_at ?? 0;
					const hungTimeoutSeconds = this._resolvedOptions.hungScheduleTimeoutSeconds;
					const elapsedSeconds = now - executionStartedAt;
					if (elapsedSeconds < hungTimeoutSeconds) {
						console.warn(`Skipping interval schedule ${row.id}: previous execution still running`);
						continue;
					}
					console.warn(`Forcing reset of hung interval schedule ${row.id} (started ${elapsedSeconds}s ago)`);
				}
				if (row.type === "interval") this.sql`UPDATE cf_agents_schedules SET running = 1, execution_started_at = ${now} WHERE id = ${row.id}`;
				await __DO_NOT_USE_WILL_BREAK__agentContext.run({
					agent: this,
					connection: void 0,
					request: void 0,
					email: void 0
				}, async () => {
					try {
						this.observability?.emit({
							displayMessage: `Schedule ${row.id} executed`,
							id: nanoid(),
							payload: {
								callback: row.callback,
								id: row.id
							},
							timestamp: Date.now(),
							type: "schedule:execute"
						}, this.ctx);
						await callback.bind(this)(JSON.parse(row.payload), row);
					} catch (e) {
						console.error(`error executing callback "${row.callback}"`, e);
						try {
							await this.onError(e);
						} catch {}
					}
				});
				if (this._destroyed) return;
				if (row.type === "cron") {
					const nextExecutionTime = getNextCronTime(row.cron);
					const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
					this.sql`
            UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
          `;
				} else if (row.type === "interval") {
					const nextTimestamp = Math.floor(Date.now() / 1e3) + (row.intervalSeconds ?? 0);
					this.sql`
            UPDATE cf_agents_schedules SET running = 0, time = ${nextTimestamp} WHERE id = ${row.id}
          `;
				} else this.sql`
            DELETE FROM cf_agents_schedules WHERE id = ${row.id}
          `;
			}
			if (this._destroyed) return;
			await this._scheduleNextAlarm();
		};
		if (!wrappedClasses.has(this.constructor)) {
			this._autoWrapCustomMethods();
			wrappedClasses.add(this.constructor);
		}
		this.sql`
        CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (
          id TEXT PRIMARY KEY NOT NULL,
          name TEXT NOT NULL,
          server_url TEXT NOT NULL,
          callback_url TEXT NOT NULL,
          client_id TEXT,
          auth_url TEXT,
          server_options TEXT
        )
      `;
		this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_state (
        id TEXT PRIMARY KEY NOT NULL,
        state TEXT
      )
    `;
		this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_queues (
        id TEXT PRIMARY KEY NOT NULL,
        payload TEXT,
        callback TEXT,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `;
		this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_schedules (
        id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
        callback TEXT,
        payload TEXT,
        type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron', 'interval')),
        time INTEGER,
        delayInSeconds INTEGER,
        cron TEXT,
        intervalSeconds INTEGER,
        running INTEGER DEFAULT 0,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `;
		const addColumnIfNotExists = (sql) => {
			try {
				this.ctx.storage.sql.exec(sql);
			} catch (e) {
				if (!(e instanceof Error ? e.message : String(e)).toLowerCase().includes("duplicate column")) throw e;
			}
		};
		addColumnIfNotExists("ALTER TABLE cf_agents_schedules ADD COLUMN intervalSeconds INTEGER");
		addColumnIfNotExists("ALTER TABLE cf_agents_schedules ADD COLUMN running INTEGER DEFAULT 0");
		addColumnIfNotExists("ALTER TABLE cf_agents_schedules ADD COLUMN execution_started_at INTEGER");
		this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_workflows (
        id TEXT PRIMARY KEY NOT NULL,
        workflow_id TEXT NOT NULL UNIQUE,
        workflow_name TEXT NOT NULL,
        status TEXT NOT NULL CHECK(status IN (
          'queued', 'running', 'paused', 'errored',
          'terminated', 'complete', 'waiting',
          'waitingForPause', 'unknown'
        )),
        metadata TEXT,
        error_name TEXT,
        error_message TEXT,
        created_at INTEGER NOT NULL DEFAULT (unixepoch()),
        updated_at INTEGER NOT NULL DEFAULT (unixepoch()),
        completed_at INTEGER
      )
    `;
		this.sql`
      CREATE INDEX IF NOT EXISTS idx_workflows_status ON cf_agents_workflows(status)
    `;
		this.sql`
      CREATE INDEX IF NOT EXISTS idx_workflows_name ON cf_agents_workflows(workflow_name)
    `;
		this.mcp = new MCPClientManager(this._ParentClass.name, "0.0.1", { storage: this.ctx.storage });
		this._disposables.add(this.mcp.onServerStateChanged(async () => {
			this.broadcastMcpServers();
		}));
		this._disposables.add(this.mcp.onObservabilityEvent((event) => {
			this.observability?.emit(event);
		}));
		{
			const proto = Object.getPrototypeOf(this);
			const hasOwnNew = Object.prototype.hasOwnProperty.call(proto, "onStateChanged");
			const hasOwnOld = Object.prototype.hasOwnProperty.call(proto, "onStateUpdate");
			if (hasOwnNew && hasOwnOld) throw new Error("[Agent] Cannot override both onStateChanged and onStateUpdate. Remove onStateUpdate — it has been renamed to onStateChanged.");
			if (hasOwnOld) {
				const ctor = this.constructor;
				if (!_onStateUpdateWarnedClasses.has(ctor)) {
					_onStateUpdateWarnedClasses.add(ctor);
					console.warn(`[Agent] onStateUpdate is deprecated. Rename to onStateChanged — the behavior is identical.`);
				}
			}
			const base = Agent.prototype;
			if (proto.onStateChanged !== base.onStateChanged) this._persistenceHookMode = "new";
			else if (proto.onStateUpdate !== base.onStateUpdate) this._persistenceHookMode = "old";
		}
		const _onRequest = this.onRequest.bind(this);
		this.onRequest = (request) => {
			return __DO_NOT_USE_WILL_BREAK__agentContext.run({
				agent: this,
				connection: void 0,
				request,
				email: void 0
			}, async () => {
				await this.mcp.ensureJsonSchema();
				const oauthResponse = await this.handleMcpOAuthCallback(request);
				if (oauthResponse) return oauthResponse;
				return this._tryCatch(() => _onRequest(request));
			});
		};
		const _onMessage = this.onMessage.bind(this);
		this.onMessage = async (connection, message) => {
			this._ensureConnectionWrapped(connection);
			return __DO_NOT_USE_WILL_BREAK__agentContext.run({
				agent: this,
				connection,
				request: void 0,
				email: void 0
			}, async () => {
				await this.mcp.ensureJsonSchema();
				if (typeof message !== "string") return this._tryCatch(() => _onMessage(connection, message));
				let parsed;
				try {
					parsed = JSON.parse(message);
				} catch (_e) {
					return this._tryCatch(() => _onMessage(connection, message));
				}
				if (isStateUpdateMessage(parsed)) {
					if (this.isConnectionReadonly(connection)) {
						connection.send(JSON.stringify({
							type: MessageType.CF_AGENT_STATE_ERROR,
							error: "Connection is readonly"
						}));
						return;
					}
					try {
						this._setStateInternal(parsed.state, connection);
					} catch (e) {
						console.error("[Agent] State update rejected:", e);
						connection.send(JSON.stringify({
							type: MessageType.CF_AGENT_STATE_ERROR,
							error: "State update rejected"
						}));
					}
					return;
				}
				if (isRPCRequest(parsed)) {
					try {
						const { id, method, args } = parsed;
						const methodFn = this[method];
						if (typeof methodFn !== "function") throw new Error(`Method ${method} does not exist`);
						if (!this._isCallable(method)) throw new Error(`Method ${method} is not callable`);
						const metadata = callableMetadata.get(methodFn);
						if (metadata?.streaming) {
							const stream = new StreamingResponse(connection, id);
							this.observability?.emit({
								displayMessage: `RPC streaming call to ${method}`,
								id: nanoid(),
								payload: {
									method,
									streaming: true
								},
								timestamp: Date.now(),
								type: "rpc"
							}, this.ctx);
							try {
								await methodFn.apply(this, [stream, ...args]);
							} catch (err) {
								console.error(`Error in streaming method "${method}":`, err);
								if (!stream.isClosed) stream.error(err instanceof Error ? err.message : String(err));
							}
							return;
						}
						const result = await methodFn.apply(this, args);
						this.observability?.emit({
							displayMessage: `RPC call to ${method}`,
							id: nanoid(),
							payload: {
								method,
								streaming: metadata?.streaming
							},
							timestamp: Date.now(),
							type: "rpc"
						}, this.ctx);
						const response = {
							done: true,
							id,
							result,
							success: true,
							type: MessageType.RPC
						};
						connection.send(JSON.stringify(response));
					} catch (e) {
						const response = {
							error: e instanceof Error ? e.message : "Unknown error occurred",
							id: parsed.id,
							success: false,
							type: MessageType.RPC
						};
						connection.send(JSON.stringify(response));
						console.error("RPC error:", e);
					}
					return;
				}
				return this._tryCatch(() => _onMessage(connection, message));
			});
		};
		const _onConnect = this.onConnect.bind(this);
		this.onConnect = (connection, ctx) => {
			this._ensureConnectionWrapped(connection);
			return __DO_NOT_USE_WILL_BREAK__agentContext.run({
				agent: this,
				connection,
				request: ctx.request,
				email: void 0
			}, async () => {
				if (this.shouldConnectionBeReadonly(connection, ctx)) this.setConnectionReadonly(connection, true);
				if (this._resolvedOptions.sendIdentityOnConnect) connection.send(JSON.stringify({
					name: this.name,
					agent: camelCaseToKebabCase(this._ParentClass.name),
					type: MessageType.CF_AGENT_IDENTITY
				}));
				if (this.state) connection.send(JSON.stringify({
					state: this.state,
					type: MessageType.CF_AGENT_STATE
				}));
				connection.send(JSON.stringify({
					mcp: this.getMcpServers(),
					type: MessageType.CF_AGENT_MCP_SERVERS
				}));
				this.observability?.emit({
					displayMessage: "Connection established",
					id: nanoid(),
					payload: { connectionId: connection.id },
					timestamp: Date.now(),
					type: "connect"
				}, this.ctx);
				return this._tryCatch(() => _onConnect(connection, ctx));
			});
		};
		const _onStart = this.onStart.bind(this);
		this.onStart = async (props) => {
			return __DO_NOT_USE_WILL_BREAK__agentContext.run({
				agent: this,
				connection: void 0,
				request: void 0,
				email: void 0
			}, async () => {
				await this._tryCatch(async () => {
					await this.mcp.restoreConnectionsFromStorage(this.name);
					this.broadcastMcpServers();
					this._checkOrphanedWorkflows();
					return _onStart(props);
				});
			});
		};
	}
	/**
	* Check for workflows referencing unknown bindings and warn with migration suggestion.
	*/
	_checkOrphanedWorkflows() {
		const orphaned = this.sql`
      SELECT 
        workflow_name,
        COUNT(*) as total,
        SUM(CASE WHEN status NOT IN ('complete', 'errored', 'terminated') THEN 1 ELSE 0 END) as active,
        SUM(CASE WHEN status IN ('complete', 'errored', 'terminated') THEN 1 ELSE 0 END) as completed
      FROM cf_agents_workflows 
      GROUP BY workflow_name
    `.filter((row) => !this._findWorkflowBindingByName(row.workflow_name));
		if (orphaned.length > 0) {
			const currentBindings = this._getWorkflowBindingNames();
			for (const { workflow_name: oldName, total, active, completed } of orphaned) {
				const suggestion = currentBindings.length === 1 ? `this.migrateWorkflowBinding('${oldName}', '${currentBindings[0]}')` : `this.migrateWorkflowBinding('${oldName}', '<NEW_BINDING_NAME>')`;
				const breakdown = active > 0 && completed > 0 ? ` (${active} active, ${completed} completed)` : active > 0 ? ` (${active} active)` : ` (${completed} completed)`;
				console.warn(`[Agent] Found ${total} workflow(s) referencing unknown binding '${oldName}'${breakdown}. If you renamed the binding, call: ${suggestion}`);
			}
		}
	}
	_setStateInternal(nextState, source = "server") {
		this.validateStateChange(nextState, source);
		this._state = nextState;
		this.sql`
      INSERT OR REPLACE INTO cf_agents_state (id, state)
      VALUES (${STATE_ROW_ID}, ${JSON.stringify(nextState)})
    `;
		this.sql`
      INSERT OR REPLACE INTO cf_agents_state (id, state)
      VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})
    `;
		this.broadcast(JSON.stringify({
			state: nextState,
			type: MessageType.CF_AGENT_STATE
		}), source !== "server" ? [source.id] : []);
		const { connection, request, email } = __DO_NOT_USE_WILL_BREAK__agentContext.getStore() || {};
		this.ctx.waitUntil((async () => {
			try {
				await __DO_NOT_USE_WILL_BREAK__agentContext.run({
					agent: this,
					connection,
					request,
					email
				}, async () => {
					this.observability?.emit({
						displayMessage: "State updated",
						id: nanoid(),
						payload: {},
						timestamp: Date.now(),
						type: "state:update"
					}, this.ctx);
					await this._callStatePersistenceHook(nextState, source);
				});
			} catch (e) {
				try {
					await this.onError(e);
				} catch {}
			}
		})());
	}
	/**
	* Update the Agent's state
	* @param state New state to set
	* @throws Error if called from a readonly connection context
	*/
	setState(state) {
		const store = __DO_NOT_USE_WILL_BREAK__agentContext.getStore();
		if (store?.connection && this.isConnectionReadonly(store.connection)) throw new Error("Connection is readonly");
		this._setStateInternal(state, "server");
	}
	/**
	* Wraps connection.state and connection.setState so that the internal
	* _cf_readonly flag is hidden from user code and cannot be accidentally
	* overwritten. Must be called before any user code sees the connection.
	*
	* Idempotent — safe to call multiple times on the same connection.
	*/
	_ensureConnectionWrapped(connection) {
		if (this._rawStateAccessors.has(connection)) return;
		const descriptor = Object.getOwnPropertyDescriptor(connection, "state");
		let getRaw;
		let setRaw;
		if (descriptor?.get) {
			getRaw = descriptor.get.bind(connection);
			setRaw = connection.setState.bind(connection);
		} else {
			let rawState = connection.state ?? null;
			getRaw = () => rawState;
			setRaw = (state) => {
				rawState = state;
				return rawState;
			};
		}
		this._rawStateAccessors.set(connection, {
			getRaw,
			setRaw
		});
		const CF_KEY = CF_READONLY_KEY;
		Object.defineProperty(connection, "state", {
			configurable: true,
			enumerable: true,
			get() {
				const raw = getRaw();
				if (raw != null && typeof raw === "object" && CF_KEY in raw) {
					const { [CF_KEY]: _, ...userState } = raw;
					return Object.keys(userState).length > 0 ? userState : null;
				}
				return raw;
			}
		});
		Object.defineProperty(connection, "setState", {
			configurable: true,
			writable: true,
			value(stateOrFn) {
				const raw = getRaw();
				const readonlyFlag = raw != null && typeof raw === "object" ? raw[CF_KEY] : void 0;
				let newUserState;
				if (typeof stateOrFn === "function") {
					let userVisible = raw;
					if (raw != null && typeof raw === "object" && CF_KEY in raw) {
						const { [CF_KEY]: _, ...rest } = raw;
						userVisible = Object.keys(rest).length > 0 ? rest : null;
					}
					newUserState = stateOrFn(userVisible);
				} else newUserState = stateOrFn;
				if (readonlyFlag !== void 0) {
					if (newUserState != null && typeof newUserState === "object") return setRaw({
						...newUserState,
						[CF_KEY]: readonlyFlag
					});
					return setRaw({ [CF_KEY]: readonlyFlag });
				}
				return setRaw(newUserState);
			}
		});
	}
	/**
	* Mark a connection as readonly or readwrite
	* @param connection The connection to mark
	* @param readonly Whether the connection should be readonly (default: true)
	*/
	setConnectionReadonly(connection, readonly = true) {
		this._ensureConnectionWrapped(connection);
		const accessors = this._rawStateAccessors.get(connection);
		const raw = accessors.getRaw() ?? {};
		if (readonly) accessors.setRaw({
			...raw,
			[CF_READONLY_KEY]: true
		});
		else {
			const { [CF_READONLY_KEY]: _, ...rest } = raw;
			accessors.setRaw(Object.keys(rest).length > 0 ? rest : null);
		}
	}
	/**
	* Check if a connection is marked as readonly
	* @param connection The connection to check
	* @returns True if the connection is readonly
	*/
	isConnectionReadonly(connection) {
		const accessors = this._rawStateAccessors.get(connection);
		if (accessors) return !!accessors.getRaw()?.[CF_READONLY_KEY];
		return false;
	}
	/**
	* Override this method to determine if a connection should be readonly on connect
	* @param _connection The connection that is being established
	* @param _ctx Connection context
	* @returns True if the connection should be readonly
	*/
	shouldConnectionBeReadonly(_connection, _ctx) {
		return false;
	}
	/**
	* Called before the Agent's state is persisted and broadcast.
	* Override to validate or reject an update by throwing an error.
	*
	* IMPORTANT: This hook must be synchronous.
	*/
	validateStateChange(nextState, source) {}
	/**
	* Called after the Agent's state has been persisted and broadcast to all clients.
	* This is a notification hook — errors here are routed to onError and do not
	* affect state persistence or client broadcasts.
	*
	* @param state Updated state
	* @param source Source of the state update ("server" or a client connection)
	*/
	onStateChanged(state, source) {}
	/**
	* @deprecated Renamed to `onStateChanged` — the behavior is identical.
	* `onStateUpdate` will be removed in the next major version.
	*
	* Called after the Agent's state has been persisted and broadcast to all clients.
	* This is a server-side notification hook. For the client-side state callback,
	* see the `onStateUpdate` option in `useAgent` / `AgentClient`.
	*
	* @param state Updated state
	* @param source Source of the state update ("server" or a client connection)
	*/
	onStateUpdate(state, source) {}
	/**
	* Dispatch to the appropriate persistence hook based on the mode
	* cached in the constructor. No prototype walks at call time.
	*/
	async _callStatePersistenceHook(state, source) {
		switch (this._persistenceHookMode) {
			case "new":
				await this.onStateChanged(state, source);
				break;
			case "old":
				await this.onStateUpdate(state, source);
				break;
		}
	}
	/**
	* Called when the Agent receives an email via routeAgentEmail()
	* Override this method to handle incoming emails
	* @param email Email message to process
	*/
	async _onEmail(email) {
		return __DO_NOT_USE_WILL_BREAK__agentContext.run({
			agent: this,
			connection: void 0,
			request: void 0,
			email
		}, async () => {
			if ("onEmail" in this && typeof this.onEmail === "function") return this._tryCatch(() => this.onEmail(email));
			else {
				console.log("Received email from:", email.from, "to:", email.to);
				console.log("Subject:", email.headers.get("subject"));
				console.log("Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails");
			}
		});
	}
	/**
	* Reply to an email
	* @param email The email to reply to
	* @param options Options for the reply
	* @param options.secret Secret for signing agent headers (enables secure reply routing).
	*   Required if the email was routed via createSecureReplyEmailResolver.
	*   Pass explicit `null` to opt-out of signing (not recommended for secure routing).
	* @returns void
	*/
	async replyToEmail(email, options) {
		return this._tryCatch(async () => {
			if (email._secureRouted && options.secret === void 0) throw new Error("This email was routed via createSecureReplyEmailResolver. You must pass a secret to replyToEmail() to sign replies, or pass explicit null to opt-out (not recommended).");
			const agentName = camelCaseToKebabCase(this._ParentClass.name);
			const agentId = this.name;
			const { createMimeMessage } = await import("mimetext");
			const msg = createMimeMessage();
			msg.setSender({
				addr: email.to,
				name: options.fromName
			});
			msg.setRecipient(email.from);
			msg.setSubject(options.subject || `Re: ${email.headers.get("subject")}` || "No subject");
			msg.addMessage({
				contentType: options.contentType || "text/plain",
				data: options.body
			});
			const messageId = `<${agentId}@${email.from.split("@")[1]}>`;
			msg.setHeader("In-Reply-To", email.headers.get("Message-ID"));
			msg.setHeader("Message-ID", messageId);
			msg.setHeader("X-Agent-Name", agentName);
			msg.setHeader("X-Agent-ID", agentId);
			if (typeof options.secret === "string") {
				const signedHeaders = await signAgentHeaders(options.secret, agentName, agentId);
				msg.setHeader("X-Agent-Sig", signedHeaders["X-Agent-Sig"]);
				msg.setHeader("X-Agent-Sig-Ts", signedHeaders["X-Agent-Sig-Ts"]);
			}
			if (options.headers) for (const [key, value] of Object.entries(options.headers)) msg.setHeader(key, value);
			await email.reply({
				from: email.to,
				raw: msg.asRaw(),
				to: email.from
			});
		});
	}
	async _tryCatch(fn) {
		try {
			return await fn();
		} catch (e) {
			throw this.onError(e);
		}
	}
	/**
	* Automatically wrap custom methods with agent context
	* This ensures getCurrentAgent() works in all custom methods without decorators
	*/
	_autoWrapCustomMethods() {
		const basePrototypes = [Agent.prototype, Server.prototype];
		const baseMethods = /* @__PURE__ */ new Set();
		for (const baseProto of basePrototypes) {
			let proto = baseProto;
			while (proto && proto !== Object.prototype) {
				const methodNames = Object.getOwnPropertyNames(proto);
				for (const methodName of methodNames) baseMethods.add(methodName);
				proto = Object.getPrototypeOf(proto);
			}
		}
		let proto = Object.getPrototypeOf(this);
		let depth = 0;
		while (proto && proto !== Object.prototype && depth < 10) {
			const methodNames = Object.getOwnPropertyNames(proto);
			for (const methodName of methodNames) {
				const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
				if (baseMethods.has(methodName) || methodName.startsWith("_") || !descriptor || !!descriptor.get || typeof descriptor.value !== "function") continue;
				const wrappedFunction = withAgentContext(this[methodName]);
				if (this._isCallable(methodName)) callableMetadata.set(wrappedFunction, callableMetadata.get(this[methodName]));
				this.constructor.prototype[methodName] = wrappedFunction;
			}
			proto = Object.getPrototypeOf(proto);
			depth++;
		}
	}
	onError(connectionOrError, error) {
		let theError;
		if (connectionOrError && error) {
			theError = error;
			console.error("Error on websocket connection:", connectionOrError.id, theError);
			console.error("Override onError(connection, error) to handle websocket connection errors");
		} else {
			theError = connectionOrError;
			console.error("Error on server:", theError);
			console.error("Override onError(error) to handle server errors");
		}
		throw theError;
	}
	/**
	* Render content (not implemented in base class)
	*/
	render() {
		throw new Error("Not implemented");
	}
	/**
	* Queue a task to be executed in the future
	* @param payload Payload to pass to the callback
	* @param callback Name of the method to call
	* @returns The ID of the queued task
	*/
	async queue(callback, payload) {
		const id = nanoid(9);
		if (typeof callback !== "string") throw new Error("Callback must be a string");
		if (typeof this[callback] !== "function") throw new Error(`this.${callback} is not a function`);
		this.sql`
      INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)
      VALUES (${id}, ${JSON.stringify(payload)}, ${callback})
    `;
		this._flushQueue().catch((e) => {
			console.error("Error flushing queue:", e);
		});
		return id;
	}
	async _flushQueue() {
		if (this._flushingQueue) return;
		this._flushingQueue = true;
		try {
			while (true) {
				const result = this.sql`
        SELECT * FROM cf_agents_queues
        ORDER BY created_at ASC
      `;
				if (!result || result.length === 0) break;
				for (const row of result || []) {
					const callback = this[row.callback];
					if (!callback) {
						console.error(`callback ${row.callback} not found`);
						await this.dequeue(row.id);
						continue;
					}
					const { connection, request, email } = __DO_NOT_USE_WILL_BREAK__agentContext.getStore() || {};
					try {
						await __DO_NOT_USE_WILL_BREAK__agentContext.run({
							agent: this,
							connection,
							request,
							email
						}, async () => {
							await callback.bind(this)(JSON.parse(row.payload), row);
						});
					} catch (e) {
						console.error(`Queue callback ${String(row.callback)} failed for row ${row.id}:`, e);
					} finally {
						await this.dequeue(row.id);
					}
				}
			}
		} finally {
			this._flushingQueue = false;
		}
	}
	/**
	* Dequeue a task by ID
	* @param id ID of the task to dequeue
	*/
	async dequeue(id) {
		this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;
	}
	/**
	* Dequeue all tasks
	*/
	async dequeueAll() {
		this.sql`DELETE FROM cf_agents_queues`;
	}
	/**
	* Dequeue all tasks by callback
	* @param callback Name of the callback to dequeue
	*/
	async dequeueAllByCallback(callback) {
		this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;
	}
	/**
	* Get a queued task by ID
	* @param id ID of the task to get
	* @returns The task or undefined if not found
	*/
	async getQueue(id) {
		const result = this.sql`
      SELECT * FROM cf_agents_queues WHERE id = ${id}
    `;
		return result ? {
			...result[0],
			payload: JSON.parse(result[0].payload)
		} : void 0;
	}
	/**
	* Get all queues by key and value
	* @param key Key to filter by
	* @param value Value to filter by
	* @returns Array of matching QueueItem objects
	*/
	async getQueues(key, value) {
		return this.sql`
      SELECT * FROM cf_agents_queues
    `.filter((row) => JSON.parse(row.payload)[key] === value);
	}
	/**
	* Schedule a task to be executed in the future
	* @template T Type of the payload data
	* @param when When to execute the task (Date, seconds delay, or cron expression)
	* @param callback Name of the method to call
	* @param payload Data to pass to the callback
	* @returns Schedule object representing the scheduled task
	*/
	async schedule(when, callback, payload) {
		const id = nanoid(9);
		const emitScheduleCreate = (schedule) => this.observability?.emit({
			displayMessage: `Schedule ${schedule.id} created`,
			id: nanoid(),
			payload: {
				callback,
				id
			},
			timestamp: Date.now(),
			type: "schedule:create"
		}, this.ctx);
		if (typeof callback !== "string") throw new Error("Callback must be a string");
		if (typeof this[callback] !== "function") throw new Error(`this.${callback} is not a function`);
		if (when instanceof Date) {
			const timestamp = Math.floor(when.getTime() / 1e3);
			this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'scheduled', ${timestamp})
      `;
			await this._scheduleNextAlarm();
			const schedule = {
				callback,
				id,
				payload,
				time: timestamp,
				type: "scheduled"
			};
			emitScheduleCreate(schedule);
			return schedule;
		}
		if (typeof when === "number") {
			const time = new Date(Date.now() + when * 1e3);
			const timestamp = Math.floor(time.getTime() / 1e3);
			this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'delayed', ${when}, ${timestamp})
      `;
			await this._scheduleNextAlarm();
			const schedule = {
				callback,
				delayInSeconds: when,
				id,
				payload,
				time: timestamp,
				type: "delayed"
			};
			emitScheduleCreate(schedule);
			return schedule;
		}
		if (typeof when === "string") {
			const nextExecutionTime = getNextCronTime(when);
			const timestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
			this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'cron', ${when}, ${timestamp})
      `;
			await this._scheduleNextAlarm();
			const schedule = {
				callback,
				cron: when,
				id,
				payload,
				time: timestamp,
				type: "cron"
			};
			emitScheduleCreate(schedule);
			return schedule;
		}
		throw new Error(`Invalid schedule type: ${JSON.stringify(when)}(${typeof when}) trying to schedule ${callback}`);
	}
	/**
	* Schedule a task to run repeatedly at a fixed interval
	* @template T Type of the payload data
	* @param intervalSeconds Number of seconds between executions
	* @param callback Name of the method to call
	* @param payload Data to pass to the callback
	* @returns Schedule object representing the scheduled task
	*/
	async scheduleEvery(intervalSeconds, callback, payload) {
		const MAX_INTERVAL_SECONDS = 720 * 60 * 60;
		if (typeof intervalSeconds !== "number" || intervalSeconds <= 0) throw new Error("intervalSeconds must be a positive number");
		if (intervalSeconds > MAX_INTERVAL_SECONDS) throw new Error(`intervalSeconds cannot exceed ${MAX_INTERVAL_SECONDS} seconds (30 days)`);
		if (typeof callback !== "string") throw new Error("Callback must be a string");
		if (typeof this[callback] !== "function") throw new Error(`this.${callback} is not a function`);
		const id = nanoid(9);
		const time = new Date(Date.now() + intervalSeconds * 1e3);
		const timestamp = Math.floor(time.getTime() / 1e3);
		this.sql`
      INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, intervalSeconds, time, running)
      VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'interval', ${intervalSeconds}, ${timestamp}, 0)
    `;
		await this._scheduleNextAlarm();
		const schedule = {
			callback,
			id,
			intervalSeconds,
			payload,
			time: timestamp,
			type: "interval"
		};
		this.observability?.emit({
			displayMessage: `Schedule ${schedule.id} created`,
			id: nanoid(),
			payload: {
				callback,
				id
			},
			timestamp: Date.now(),
			type: "schedule:create"
		}, this.ctx);
		return schedule;
	}
	/**
	* Get a scheduled task by ID
	* @template T Type of the payload data
	* @param id ID of the scheduled task
	* @returns The Schedule object or undefined if not found
	*/
	async getSchedule(id) {
		const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE id = ${id}
    `;
		if (!result || result.length === 0) return;
		return {
			...result[0],
			payload: JSON.parse(result[0].payload)
		};
	}
	/**
	* Get scheduled tasks matching the given criteria
	* @template T Type of the payload data
	* @param criteria Criteria to filter schedules
	* @returns Array of matching Schedule objects
	*/
	getSchedules(criteria = {}) {
		let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
		const params = [];
		if (criteria.id) {
			query += " AND id = ?";
			params.push(criteria.id);
		}
		if (criteria.type) {
			query += " AND type = ?";
			params.push(criteria.type);
		}
		if (criteria.timeRange) {
			query += " AND time >= ? AND time <= ?";
			const start = criteria.timeRange.start || /* @__PURE__ */ new Date(0);
			const end = criteria.timeRange.end || /* @__PURE__ */ new Date(999999999999999);
			params.push(Math.floor(start.getTime() / 1e3), Math.floor(end.getTime() / 1e3));
		}
		return this.ctx.storage.sql.exec(query, ...params).toArray().map((row) => ({
			...row,
			payload: JSON.parse(row.payload)
		}));
	}
	/**
	* Cancel a scheduled task
	* @param id ID of the task to cancel
	* @returns true if the task was cancelled, false if the task was not found
	*/
	async cancelSchedule(id) {
		const schedule = await this.getSchedule(id);
		if (!schedule) return false;
		this.observability?.emit({
			displayMessage: `Schedule ${id} cancelled`,
			id: nanoid(),
			payload: {
				callback: schedule.callback,
				id: schedule.id
			},
			timestamp: Date.now(),
			type: "schedule:cancel"
		}, this.ctx);
		this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
		await this._scheduleNextAlarm();
		return true;
	}
	async _scheduleNextAlarm() {
		const result = this.sql`
      SELECT time FROM cf_agents_schedules
      WHERE time >= ${Math.floor(Date.now() / 1e3)}
      ORDER BY time ASC
      LIMIT 1
    `;
		if (!result) return;
		if (result.length > 0 && "time" in result[0]) {
			const nextTime = result[0].time * 1e3;
			await this.ctx.storage.setAlarm(nextTime);
		}
	}
	/**
	* Destroy the Agent, removing all state and scheduled tasks
	*/
	async destroy() {
		this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;
		this.sql`DROP TABLE IF EXISTS cf_agents_state`;
		this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
		this.sql`DROP TABLE IF EXISTS cf_agents_queues`;
		this.sql`DROP TABLE IF EXISTS cf_agents_workflows`;
		await this.ctx.storage.deleteAlarm();
		await this.ctx.storage.deleteAll();
		this._disposables.dispose();
		await this.mcp.dispose();
		this._destroyed = true;
		setTimeout(() => {
			this.ctx.abort("destroyed");
		}, 0);
		this.observability?.emit({
			displayMessage: "Agent destroyed",
			id: nanoid(),
			payload: {},
			timestamp: Date.now(),
			type: "destroy"
		}, this.ctx);
	}
	/**
	* Check if a method is callable
	* @param method The method name to check
	* @returns True if the method is marked as callable
	*/
	_isCallable(method) {
		return callableMetadata.has(this[method]);
	}
	/**
	* Get all methods marked as callable on this Agent
	* @returns A map of method names to their metadata
	*/
	getCallableMethods() {
		const result = /* @__PURE__ */ new Map();
		let prototype = Object.getPrototypeOf(this);
		while (prototype && prototype !== Object.prototype) {
			for (const name of Object.getOwnPropertyNames(prototype)) {
				if (name === "constructor") continue;
				if (result.has(name)) continue;
				try {
					const fn = prototype[name];
					if (typeof fn === "function") {
						const meta = callableMetadata.get(fn);
						if (meta) result.set(name, meta);
					}
				} catch (e) {
					if (!(e instanceof TypeError)) throw e;
				}
			}
			prototype = Object.getPrototypeOf(prototype);
		}
		return result;
	}
	/**
	* Start a workflow and track it in this Agent's database.
	* Automatically injects agent identity into the workflow params.
	*
	* @template P - Type of params to pass to the workflow
	* @param workflowName - Name of the workflow binding in env (e.g., 'MY_WORKFLOW')
	* @param params - Params to pass to the workflow
	* @param options - Optional workflow options
	* @returns The workflow instance ID
	*
	* @example
	* ```typescript
	* const workflowId = await this.runWorkflow(
	*   'MY_WORKFLOW',
	*   { taskId: '123', data: 'process this' }
	* );
	* ```
	*/
	async runWorkflow(workflowName, params, options) {
		const workflow = this._findWorkflowBindingByName(workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowName}' not found in environment`);
		const agentBindingName = options?.agentBinding ?? this._findAgentBindingName();
		if (!agentBindingName) throw new Error("Could not detect Agent binding name from class name. Pass it explicitly via options.agentBinding");
		const workflowId = options?.id ?? nanoid();
		const augmentedParams = {
			...params,
			__agentName: this.name,
			__agentBinding: agentBindingName,
			__workflowName: workflowName
		};
		const instance = await workflow.create({
			id: workflowId,
			params: augmentedParams
		});
		const id = nanoid();
		const metadataJson = options?.metadata ? JSON.stringify(options.metadata) : null;
		try {
			this.sql`
        INSERT INTO cf_agents_workflows (id, workflow_id, workflow_name, status, metadata)
        VALUES (${id}, ${instance.id}, ${workflowName}, 'queued', ${metadataJson})
      `;
		} catch (e) {
			if (e instanceof Error && e.message.includes("UNIQUE constraint failed")) throw new Error(`Workflow with ID "${workflowId}" is already being tracked`);
			throw e;
		}
		this.observability?.emit({
			displayMessage: `Workflow ${instance.id} started`,
			id: nanoid(),
			payload: {
				workflowId: instance.id,
				workflowName
			},
			timestamp: Date.now(),
			type: "workflow:start"
		}, this.ctx);
		return instance.id;
	}
	/**
	* Send an event to a running workflow.
	* The workflow can wait for this event using step.waitForEvent().
	*
	* @param workflowName - Name of the workflow binding in env (e.g., 'MY_WORKFLOW')
	* @param workflowId - ID of the workflow instance
	* @param event - Event to send
	*
	* @example
	* ```typescript
	* await this.sendWorkflowEvent(
	*   'MY_WORKFLOW',
	*   workflowId,
	*   { type: 'approval', payload: { approved: true } }
	* );
	* ```
	*/
	async sendWorkflowEvent(workflowName, workflowId, event) {
		const workflow = this._findWorkflowBindingByName(workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowName}' not found in environment`);
		await (await workflow.get(workflowId)).sendEvent(event);
		this.observability?.emit({
			displayMessage: `Event sent to workflow ${workflowId}`,
			id: nanoid(),
			payload: {
				workflowId,
				eventType: event.type
			},
			timestamp: Date.now(),
			type: "workflow:event"
		}, this.ctx);
	}
	/**
	* Approve a waiting workflow.
	* Sends an approval event to the workflow that can be received by waitForApproval().
	*
	* @param workflowId - ID of the workflow to approve
	* @param data - Optional approval data (reason, metadata)
	*
	* @example
	* ```typescript
	* await this.approveWorkflow(workflowId, {
	*   reason: 'Approved by admin',
	*   metadata: { approvedBy: userId }
	* });
	* ```
	*/
	async approveWorkflow(workflowId, data) {
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		await this.sendWorkflowEvent(workflowInfo.workflowName, workflowId, {
			type: "approval",
			payload: {
				approved: true,
				reason: data?.reason,
				metadata: data?.metadata
			}
		});
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} approved`,
			id: nanoid(),
			payload: {
				workflowId,
				reason: data?.reason
			},
			timestamp: Date.now(),
			type: "workflow:approved"
		}, this.ctx);
	}
	/**
	* Reject a waiting workflow.
	* Sends a rejection event to the workflow that will cause waitForApproval() to throw.
	*
	* @param workflowId - ID of the workflow to reject
	* @param data - Optional rejection data (reason)
	*
	* @example
	* ```typescript
	* await this.rejectWorkflow(workflowId, {
	*   reason: 'Request denied by admin'
	* });
	* ```
	*/
	async rejectWorkflow(workflowId, data) {
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		await this.sendWorkflowEvent(workflowInfo.workflowName, workflowId, {
			type: "approval",
			payload: {
				approved: false,
				reason: data?.reason
			}
		});
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} rejected`,
			id: nanoid(),
			payload: {
				workflowId,
				reason: data?.reason
			},
			timestamp: Date.now(),
			type: "workflow:rejected"
		}, this.ctx);
	}
	/**
	* Terminate a running workflow.
	* This immediately stops the workflow and sets its status to "terminated".
	*
	* @param workflowId - ID of the workflow to terminate (must be tracked via runWorkflow)
	* @throws Error if workflow not found in tracking table
	* @throws Error if workflow binding not found in environment
	* @throws Error if workflow is already completed/errored/terminated (from Cloudflare)
	*
	* @note `terminate()` is not yet supported in local development (wrangler dev).
	* It will throw an error locally but works when deployed to Cloudflare.
	*
	* @example
	* ```typescript
	* await this.terminateWorkflow(workflowId);
	* ```
	*/
	async terminateWorkflow(workflowId) {
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		const workflow = this._findWorkflowBindingByName(workflowInfo.workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowInfo.workflowName}' not found in environment`);
		const instance = await workflow.get(workflowId);
		try {
			await instance.terminate();
		} catch (err) {
			if (err instanceof Error && err.message.includes("Not implemented")) throw new Error("terminateWorkflow() is not supported in local development. Deploy to Cloudflare to use this feature. Follow https://github.com/cloudflare/agents/issues/823 for details and updates.");
			throw err;
		}
		const status = await instance.status();
		this._updateWorkflowTracking(workflowId, status);
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} terminated`,
			id: nanoid(),
			payload: {
				workflowId,
				workflowName: workflowInfo.workflowName
			},
			timestamp: Date.now(),
			type: "workflow:terminated"
		}, this.ctx);
	}
	/**
	* Pause a running workflow.
	* The workflow can be resumed later with resumeWorkflow().
	*
	* @param workflowId - ID of the workflow to pause (must be tracked via runWorkflow)
	* @throws Error if workflow not found in tracking table
	* @throws Error if workflow binding not found in environment
	* @throws Error if workflow is not running (from Cloudflare)
	*
	* @note `pause()` is not yet supported in local development (wrangler dev).
	* It will throw an error locally but works when deployed to Cloudflare.
	*
	* @example
	* ```typescript
	* await this.pauseWorkflow(workflowId);
	* ```
	*/
	async pauseWorkflow(workflowId) {
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		const workflow = this._findWorkflowBindingByName(workflowInfo.workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowInfo.workflowName}' not found in environment`);
		const instance = await workflow.get(workflowId);
		try {
			await instance.pause();
		} catch (err) {
			if (err instanceof Error && err.message.includes("Not implemented")) throw new Error("pauseWorkflow() is not supported in local development. Deploy to Cloudflare to use this feature. Follow https://github.com/cloudflare/agents/issues/823 for details and updates.");
			throw err;
		}
		const status = await instance.status();
		this._updateWorkflowTracking(workflowId, status);
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} paused`,
			id: nanoid(),
			payload: {
				workflowId,
				workflowName: workflowInfo.workflowName
			},
			timestamp: Date.now(),
			type: "workflow:paused"
		}, this.ctx);
	}
	/**
	* Resume a paused workflow.
	*
	* @param workflowId - ID of the workflow to resume (must be tracked via runWorkflow)
	* @throws Error if workflow not found in tracking table
	* @throws Error if workflow binding not found in environment
	* @throws Error if workflow is not paused (from Cloudflare)
	*
	* @note `resume()` is not yet supported in local development (wrangler dev).
	* It will throw an error locally but works when deployed to Cloudflare.
	*
	* @example
	* ```typescript
	* await this.resumeWorkflow(workflowId);
	* ```
	*/
	async resumeWorkflow(workflowId) {
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		const workflow = this._findWorkflowBindingByName(workflowInfo.workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowInfo.workflowName}' not found in environment`);
		const instance = await workflow.get(workflowId);
		try {
			await instance.resume();
		} catch (err) {
			if (err instanceof Error && err.message.includes("Not implemented")) throw new Error("resumeWorkflow() is not supported in local development. Deploy to Cloudflare to use this feature. Follow https://github.com/cloudflare/agents/issues/823 for details and updates.");
			throw err;
		}
		const status = await instance.status();
		this._updateWorkflowTracking(workflowId, status);
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} resumed`,
			id: nanoid(),
			payload: {
				workflowId,
				workflowName: workflowInfo.workflowName
			},
			timestamp: Date.now(),
			type: "workflow:resumed"
		}, this.ctx);
	}
	/**
	* Restart a workflow instance.
	* This re-runs the workflow from the beginning with the same ID.
	*
	* @param workflowId - ID of the workflow to restart (must be tracked via runWorkflow)
	* @param options - Optional settings
	* @param options.resetTracking - If true (default), resets created_at and clears error fields.
	*                                If false, preserves original timestamps.
	* @throws Error if workflow not found in tracking table
	* @throws Error if workflow binding not found in environment
	*
	* @note `restart()` is not yet supported in local development (wrangler dev).
	* It will throw an error locally but works when deployed to Cloudflare.
	*
	* @example
	* ```typescript
	* // Reset tracking (default)
	* await this.restartWorkflow(workflowId);
	*
	* // Preserve original timestamps
	* await this.restartWorkflow(workflowId, { resetTracking: false });
	* ```
	*/
	async restartWorkflow(workflowId, options = {}) {
		const { resetTracking = true } = options;
		const workflowInfo = this.getWorkflow(workflowId);
		if (!workflowInfo) throw new Error(`Workflow ${workflowId} not found in tracking table`);
		const workflow = this._findWorkflowBindingByName(workflowInfo.workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowInfo.workflowName}' not found in environment`);
		const instance = await workflow.get(workflowId);
		try {
			await instance.restart();
		} catch (err) {
			if (err instanceof Error && err.message.includes("Not implemented")) throw new Error("restartWorkflow() is not supported in local development. Deploy to Cloudflare to use this feature. Follow https://github.com/cloudflare/agents/issues/823 for details and updates.");
			throw err;
		}
		if (resetTracking) {
			const now = Math.floor(Date.now() / 1e3);
			this.sql`
        UPDATE cf_agents_workflows
        SET status = 'queued',
            created_at = ${now},
            updated_at = ${now},
            completed_at = NULL,
            error_name = NULL,
            error_message = NULL
        WHERE workflow_id = ${workflowId}
      `;
		} else {
			const status = await instance.status();
			this._updateWorkflowTracking(workflowId, status);
		}
		this.observability?.emit({
			displayMessage: `Workflow ${workflowId} restarted`,
			id: nanoid(),
			payload: {
				workflowId,
				workflowName: workflowInfo.workflowName
			},
			timestamp: Date.now(),
			type: "workflow:restarted"
		}, this.ctx);
	}
	/**
	* Find a workflow binding by its name.
	*/
	_findWorkflowBindingByName(workflowName) {
		const binding = this.env[workflowName];
		if (binding && typeof binding === "object" && "create" in binding && "get" in binding) return binding;
	}
	/**
	* Get all workflow binding names from the environment.
	*/
	_getWorkflowBindingNames() {
		const names = [];
		for (const [key, value] of Object.entries(this.env)) if (value && typeof value === "object" && "create" in value && "get" in value) names.push(key);
		return names;
	}
	/**
	* Get the status of a workflow and update the tracking record.
	*
	* @param workflowName - Name of the workflow binding in env (e.g., 'MY_WORKFLOW')
	* @param workflowId - ID of the workflow instance
	* @returns The workflow status
	*/
	async getWorkflowStatus(workflowName, workflowId) {
		const workflow = this._findWorkflowBindingByName(workflowName);
		if (!workflow) throw new Error(`Workflow binding '${workflowName}' not found in environment`);
		const status = await (await workflow.get(workflowId)).status();
		this._updateWorkflowTracking(workflowId, status);
		return status;
	}
	/**
	* Get a tracked workflow by ID.
	*
	* @param workflowId - Workflow instance ID
	* @returns Workflow info or undefined if not found
	*/
	getWorkflow(workflowId) {
		const rows = this.sql`
      SELECT * FROM cf_agents_workflows WHERE workflow_id = ${workflowId}
    `;
		if (!rows || rows.length === 0) return;
		return this._rowToWorkflowInfo(rows[0]);
	}
	/**
	* Query tracked workflows with cursor-based pagination.
	*
	* @param criteria - Query criteria including optional cursor for pagination
	* @returns WorkflowPage with workflows, total count, and next cursor
	*
	* @example
	* ```typescript
	* // First page
	* const page1 = this.getWorkflows({ status: 'running', limit: 20 });
	*
	* // Next page
	* if (page1.nextCursor) {
	*   const page2 = this.getWorkflows({
	*     status: 'running',
	*     limit: 20,
	*     cursor: page1.nextCursor
	*   });
	* }
	* ```
	*/
	getWorkflows(criteria = {}) {
		const limit = Math.min(criteria.limit ?? 50, 100);
		const isAsc = criteria.orderBy === "asc";
		const total = this._countWorkflows(criteria);
		let query = "SELECT * FROM cf_agents_workflows WHERE 1=1";
		const params = [];
		if (criteria.status) {
			const statuses = Array.isArray(criteria.status) ? criteria.status : [criteria.status];
			const placeholders = statuses.map(() => "?").join(", ");
			query += ` AND status IN (${placeholders})`;
			params.push(...statuses);
		}
		if (criteria.workflowName) {
			query += " AND workflow_name = ?";
			params.push(criteria.workflowName);
		}
		if (criteria.metadata) for (const [key, value] of Object.entries(criteria.metadata)) {
			query += ` AND json_extract(metadata, '$.' || ?) = ?`;
			params.push(key, value);
		}
		if (criteria.cursor) {
			const cursor = this._decodeCursor(criteria.cursor);
			if (isAsc) query += " AND (created_at > ? OR (created_at = ? AND workflow_id > ?))";
			else query += " AND (created_at < ? OR (created_at = ? AND workflow_id < ?))";
			params.push(cursor.createdAt, cursor.createdAt, cursor.workflowId);
		}
		query += ` ORDER BY created_at ${isAsc ? "ASC" : "DESC"}, workflow_id ${isAsc ? "ASC" : "DESC"}`;
		query += " LIMIT ?";
		params.push(limit + 1);
		const rows = this.ctx.storage.sql.exec(query, ...params).toArray();
		const hasMore = rows.length > limit;
		const workflows = (hasMore ? rows.slice(0, limit) : rows).map((row) => this._rowToWorkflowInfo(row));
		return {
			workflows,
			total,
			nextCursor: hasMore && workflows.length > 0 ? this._encodeCursor(workflows[workflows.length - 1]) : null
		};
	}
	/**
	* Count workflows matching criteria (for pagination total).
	*/
	_countWorkflows(criteria) {
		let query = "SELECT COUNT(*) as count FROM cf_agents_workflows WHERE 1=1";
		const params = [];
		if (criteria.status) {
			const statuses = Array.isArray(criteria.status) ? criteria.status : [criteria.status];
			const placeholders = statuses.map(() => "?").join(", ");
			query += ` AND status IN (${placeholders})`;
			params.push(...statuses);
		}
		if (criteria.workflowName) {
			query += " AND workflow_name = ?";
			params.push(criteria.workflowName);
		}
		if (criteria.metadata) for (const [key, value] of Object.entries(criteria.metadata)) {
			query += ` AND json_extract(metadata, '$.' || ?) = ?`;
			params.push(key, value);
		}
		if (criteria.createdBefore) {
			query += " AND created_at < ?";
			params.push(Math.floor(criteria.createdBefore.getTime() / 1e3));
		}
		return this.ctx.storage.sql.exec(query, ...params).toArray()[0]?.count ?? 0;
	}
	/**
	* Encode a cursor from workflow info for pagination.
	* Stores createdAt as Unix timestamp in seconds (matching DB storage).
	*/
	_encodeCursor(workflow) {
		return btoa(JSON.stringify({
			c: Math.floor(workflow.createdAt.getTime() / 1e3),
			i: workflow.workflowId
		}));
	}
	/**
	* Decode a pagination cursor.
	* Returns createdAt as Unix timestamp in seconds (matching DB storage).
	*/
	_decodeCursor(cursor) {
		try {
			const data = JSON.parse(atob(cursor));
			if (typeof data.c !== "number" || typeof data.i !== "string") throw new Error("Invalid cursor structure");
			return {
				createdAt: data.c,
				workflowId: data.i
			};
		} catch {
			throw new Error("Invalid pagination cursor. The cursor may be malformed or corrupted.");
		}
	}
	/**
	* Delete a workflow tracking record.
	*
	* @param workflowId - ID of the workflow to delete
	* @returns true if a record was deleted, false if not found
	*/
	deleteWorkflow(workflowId) {
		const existing = this.sql`
      SELECT COUNT(*) as count FROM cf_agents_workflows WHERE workflow_id = ${workflowId}
    `;
		if (!existing[0] || existing[0].count === 0) return false;
		this.sql`DELETE FROM cf_agents_workflows WHERE workflow_id = ${workflowId}`;
		return true;
	}
	/**
	* Delete workflow tracking records matching criteria.
	* Useful for cleaning up old completed/errored workflows.
	*
	* @param criteria - Criteria for which workflows to delete
	* @returns Number of records matching criteria (expected deleted count)
	*
	* @example
	* ```typescript
	* // Delete all completed workflows created more than 7 days ago
	* const deleted = this.deleteWorkflows({
	*   status: 'complete',
	*   createdBefore: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
	* });
	*
	* // Delete all errored and terminated workflows
	* const deleted = this.deleteWorkflows({
	*   status: ['errored', 'terminated']
	* });
	* ```
	*/
	deleteWorkflows(criteria = {}) {
		let query = "DELETE FROM cf_agents_workflows WHERE 1=1";
		const params = [];
		if (criteria.status) {
			const statuses = Array.isArray(criteria.status) ? criteria.status : [criteria.status];
			const placeholders = statuses.map(() => "?").join(", ");
			query += ` AND status IN (${placeholders})`;
			params.push(...statuses);
		}
		if (criteria.workflowName) {
			query += " AND workflow_name = ?";
			params.push(criteria.workflowName);
		}
		if (criteria.metadata) for (const [key, value] of Object.entries(criteria.metadata)) {
			query += ` AND json_extract(metadata, '$.' || ?) = ?`;
			params.push(key, value);
		}
		if (criteria.createdBefore) {
			query += " AND created_at < ?";
			params.push(Math.floor(criteria.createdBefore.getTime() / 1e3));
		}
		return this.ctx.storage.sql.exec(query, ...params).rowsWritten;
	}
	/**
	* Migrate workflow tracking records from an old binding name to a new one.
	* Use this after renaming a workflow binding in wrangler.toml.
	*
	* @param oldName - Previous workflow binding name
	* @param newName - New workflow binding name
	* @returns Number of records migrated
	*
	* @example
	* ```typescript
	* // After renaming OLD_WORKFLOW to NEW_WORKFLOW in wrangler.toml
	* async onStart() {
	*   const migrated = this.migrateWorkflowBinding('OLD_WORKFLOW', 'NEW_WORKFLOW');
	* }
	* ```
	*/
	migrateWorkflowBinding(oldName, newName) {
		if (!this._findWorkflowBindingByName(newName)) throw new Error(`Workflow binding '${newName}' not found in environment`);
		const count = this.sql`
      SELECT COUNT(*) as count FROM cf_agents_workflows WHERE workflow_name = ${oldName}
    `[0]?.count ?? 0;
		if (count > 0) {
			this.sql`UPDATE cf_agents_workflows SET workflow_name = ${newName} WHERE workflow_name = ${oldName}`;
			console.log(`[Agent] Migrated ${count} workflow(s) from '${oldName}' to '${newName}'`);
		}
		return count;
	}
	/**
	* Update workflow tracking record from InstanceStatus
	*/
	_updateWorkflowTracking(workflowId, status) {
		const statusName = status.status;
		const now = Math.floor(Date.now() / 1e3);
		const completedAt = [
			"complete",
			"errored",
			"terminated"
		].includes(statusName) ? now : null;
		const errorName = status.error?.name ?? null;
		const errorMessage = status.error?.message ?? null;
		this.sql`
      UPDATE cf_agents_workflows
      SET status = ${statusName},
          error_name = ${errorName},
          error_message = ${errorMessage},
          updated_at = ${now},
          completed_at = ${completedAt}
      WHERE workflow_id = ${workflowId}
    `;
	}
	/**
	* Convert a database row to WorkflowInfo
	*/
	_rowToWorkflowInfo(row) {
		return {
			id: row.id,
			workflowId: row.workflow_id,
			workflowName: row.workflow_name,
			status: row.status,
			metadata: row.metadata ? JSON.parse(row.metadata) : null,
			error: row.error_name ? {
				name: row.error_name,
				message: row.error_message ?? ""
			} : null,
			createdAt: /* @__PURE__ */ new Date(row.created_at * 1e3),
			updatedAt: /* @__PURE__ */ new Date(row.updated_at * 1e3),
			completedAt: row.completed_at ? /* @__PURE__ */ new Date(row.completed_at * 1e3) : null
		};
	}
	/**
	* Find the binding name for this Agent's namespace by matching class name.
	* Returns undefined if no match found - use options.agentBinding as fallback.
	*/
	_findAgentBindingName() {
		const className = this._ParentClass.name;
		for (const [key, value] of Object.entries(this.env)) if (value && typeof value === "object" && "idFromName" in value && typeof value.idFromName === "function") {
			if (key === className || camelCaseToKebabCase(key) === camelCaseToKebabCase(className)) return key;
		}
	}
	/**
	* Handle a callback from a workflow.
	* Called when the Agent receives a callback at /_workflow/callback.
	* Override this to handle all callback types in one place.
	*
	* @param callback - The callback payload
	*/
	async onWorkflowCallback(callback) {
		const now = Math.floor(Date.now() / 1e3);
		switch (callback.type) {
			case "progress":
				this.sql`
          UPDATE cf_agents_workflows
          SET status = 'running', updated_at = ${now}
          WHERE workflow_id = ${callback.workflowId} AND status IN ('queued', 'waiting')
        `;
				await this.onWorkflowProgress(callback.workflowName, callback.workflowId, callback.progress);
				break;
			case "complete":
				this.sql`
          UPDATE cf_agents_workflows
          SET status = 'complete', updated_at = ${now}, completed_at = ${now}
          WHERE workflow_id = ${callback.workflowId}
            AND status NOT IN ('terminated', 'paused')
        `;
				await this.onWorkflowComplete(callback.workflowName, callback.workflowId, callback.result);
				break;
			case "error":
				this.sql`
          UPDATE cf_agents_workflows
          SET status = 'errored', updated_at = ${now}, completed_at = ${now},
              error_name = 'WorkflowError', error_message = ${callback.error}
          WHERE workflow_id = ${callback.workflowId}
            AND status NOT IN ('terminated', 'paused')
        `;
				await this.onWorkflowError(callback.workflowName, callback.workflowId, callback.error);
				break;
			case "event":
				await this.onWorkflowEvent(callback.workflowName, callback.workflowId, callback.event);
				break;
		}
	}
	/**
	* Called when a workflow reports progress.
	* Override to handle progress updates.
	*
	* @param workflowName - Workflow binding name
	* @param workflowId - ID of the workflow
	* @param progress - Typed progress data (default: DefaultProgress)
	*/
	async onWorkflowProgress(_workflowName, _workflowId, _progress) {}
	/**
	* Called when a workflow completes successfully.
	* Override to handle completion.
	*
	* @param workflowName - Workflow binding name
	* @param workflowId - ID of the workflow
	* @param result - Optional result data
	*/
	async onWorkflowComplete(_workflowName, _workflowId, _result) {}
	/**
	* Called when a workflow encounters an error.
	* Override to handle errors.
	*
	* @param workflowName - Workflow binding name
	* @param workflowId - ID of the workflow
	* @param error - Error message
	*/
	async onWorkflowError(_workflowName, _workflowId, _error) {}
	/**
	* Called when a workflow sends a custom event.
	* Override to handle custom events.
	*
	* @param workflowName - Workflow binding name
	* @param workflowId - ID of the workflow
	* @param event - Custom event payload
	*/
	async onWorkflowEvent(_workflowName, _workflowId, _event) {}
	/**
	* Handle a workflow callback via RPC.
	* @internal - Called by AgentWorkflow, do not call directly
	*/
	async _workflow_handleCallback(callback) {
		await this.onWorkflowCallback(callback);
	}
	/**
	* Broadcast a message to all connected clients via RPC.
	* @internal - Called by AgentWorkflow, do not call directly
	*/
	_workflow_broadcast(message) {
		this.broadcast(JSON.stringify(message));
	}
	/**
	* Update agent state via RPC.
	* @internal - Called by AgentWorkflow, do not call directly
	*/
	_workflow_updateState(action, state) {
		if (action === "set") this.setState(state);
		else if (action === "merge") {
			const currentState = this.state ?? {};
			this.setState({
				...currentState,
				...state
			});
		} else if (action === "reset") this.setState(this.initialState);
	}
	/**
	* Connect to a new MCP Server
	*
	* @example
	* // Simple usage
	* await this.addMcpServer("github", "https://mcp.github.com");
	*
	* @example
	* // With options (preferred for custom headers, transport, etc.)
	* await this.addMcpServer("github", "https://mcp.github.com", {
	*   transport: { headers: { "Authorization": "Bearer ..." } }
	* });
	*
	* @example
	* // Legacy 5-parameter signature (still supported)
	* await this.addMcpServer("github", url, callbackHost, agentsPrefix, options);
	*
	* @param serverName Name of the MCP server
	* @param url MCP Server URL
	* @param callbackHostOrOptions Options object, or callback host string (legacy)
	* @param agentsPrefix agents routing prefix if not using `agents` (legacy)
	* @param options MCP client and transport options (legacy)
	* @returns Server id and state - either "authenticating" with authUrl, or "ready"
	* @throws If connection or discovery fails
	*/
	async addMcpServer(serverName, url, callbackHostOrOptions, agentsPrefix, options) {
		let resolvedCallbackHost;
		let resolvedAgentsPrefix;
		let resolvedOptions;
		let resolvedCallbackPath;
		if (typeof callbackHostOrOptions === "object" && callbackHostOrOptions !== null) {
			resolvedCallbackHost = callbackHostOrOptions.callbackHost;
			resolvedCallbackPath = callbackHostOrOptions.callbackPath;
			resolvedAgentsPrefix = callbackHostOrOptions.agentsPrefix ?? "agents";
			resolvedOptions = {
				client: callbackHostOrOptions.client,
				transport: callbackHostOrOptions.transport
			};
		} else {
			resolvedCallbackHost = callbackHostOrOptions;
			resolvedAgentsPrefix = agentsPrefix ?? "agents";
			resolvedOptions = options;
		}
		if (!this._resolvedOptions.sendIdentityOnConnect && !resolvedCallbackPath) throw new Error("callbackPath is required in addMcpServer options when sendIdentityOnConnect is false — the default callback URL would expose the instance name. Provide a callbackPath and route the callback request to this agent via getAgentByName.");
		if (!resolvedCallbackHost) {
			const { request } = getCurrentAgent();
			if (!request) throw new Error("callbackHost is required when not called within a request context");
			const requestUrl = new URL(request.url);
			resolvedCallbackHost = `${requestUrl.protocol}//${requestUrl.host}`;
		}
		const normalizedHost = resolvedCallbackHost.replace(/\/$/, "");
		const callbackUrl = resolvedCallbackPath ? `${normalizedHost}/${resolvedCallbackPath.replace(/^\//, "")}` : `${normalizedHost}/${resolvedAgentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;
		await this.mcp.ensureJsonSchema();
		const id = nanoid(8);
		const authProvider = this.createMcpOAuthProvider(callbackUrl);
		authProvider.serverId = id;
		const transportType = resolvedOptions?.transport?.type ?? "auto";
		let headerTransportOpts = {};
		if (resolvedOptions?.transport?.headers) headerTransportOpts = {
			eventSourceInit: { fetch: (url, init) => fetch(url, {
				...init,
				headers: resolvedOptions?.transport?.headers
			}) },
			requestInit: { headers: resolvedOptions?.transport?.headers }
		};
		await this.mcp.registerServer(id, {
			url,
			name: serverName,
			callbackUrl,
			client: resolvedOptions?.client,
			transport: {
				...headerTransportOpts,
				authProvider,
				type: transportType
			}
		});
		const result = await this.mcp.connectToServer(id);
		if (result.state === MCPConnectionState.FAILED) throw new Error(`Failed to connect to MCP server at ${url}: ${result.error}`);
		if (result.state === MCPConnectionState.AUTHENTICATING) return {
			id,
			state: result.state,
			authUrl: result.authUrl
		};
		const discoverResult = await this.mcp.discoverIfConnected(id);
		if (discoverResult && !discoverResult.success) throw new Error(`Failed to discover MCP server capabilities: ${discoverResult.error}`);
		return {
			id,
			state: MCPConnectionState.READY
		};
	}
	async removeMcpServer(id) {
		await this.mcp.removeServer(id);
	}
	getMcpServers() {
		const mcpState = {
			prompts: this.mcp.listPrompts(),
			resources: this.mcp.listResources(),
			servers: {},
			tools: this.mcp.listTools()
		};
		const servers = this.mcp.listServers();
		if (servers && Array.isArray(servers) && servers.length > 0) for (const server of servers) {
			const serverConn = this.mcp.mcpConnections[server.id];
			let defaultState = "not-connected";
			if (!serverConn && server.auth_url) defaultState = "authenticating";
			mcpState.servers[server.id] = {
				auth_url: server.auth_url,
				capabilities: serverConn?.serverCapabilities ?? null,
				error: serverConn?.connectionError ?? null,
				instructions: serverConn?.instructions ?? null,
				name: server.name,
				server_url: server.server_url,
				state: serverConn?.connectionState ?? defaultState
			};
		}
		return mcpState;
	}
	/**
	* Create the OAuth provider used when connecting to MCP servers that require authentication.
	*
	* Override this method in a subclass to supply a custom OAuth provider implementation,
	* for example to use pre-registered client credentials, mTLS-based authentication,
	* or any other OAuth flow beyond dynamic client registration.
	*
	* @example
	* // Custom OAuth provider
	* class MyAgent extends Agent {
	*   createMcpOAuthProvider(callbackUrl: string): AgentMcpOAuthProvider {
	*     return new MyCustomOAuthProvider(
	*       this.ctx.storage,
	*       this.name,
	*       callbackUrl
	*     );
	*   }
	* }
	*
	* @param callbackUrl The OAuth callback URL for the authorization flow
	* @returns An {@link AgentMcpOAuthProvider} instance used by {@link addMcpServer}
	*/
	createMcpOAuthProvider(callbackUrl) {
		return new DurableObjectOAuthClientProvider(this.ctx.storage, this.name, callbackUrl);
	}
	broadcastMcpServers() {
		this.broadcast(JSON.stringify({
			mcp: this.getMcpServers(),
			type: MessageType.CF_AGENT_MCP_SERVERS
		}));
	}
	/**
	* Handle MCP OAuth callback request if it's an OAuth callback.
	*
	* This method encapsulates the entire OAuth callback flow:
	* 1. Checks if the request is an MCP OAuth callback
	* 2. Processes the OAuth code exchange
	* 3. Establishes the connection if successful
	* 4. Broadcasts MCP server state updates
	* 5. Returns the appropriate HTTP response
	*
	* @param request The incoming HTTP request
	* @returns Response if this was an OAuth callback, null otherwise
	*/
	async handleMcpOAuthCallback(request) {
		if (!this.mcp.isCallbackRequest(request)) return null;
		const result = await this.mcp.handleCallbackRequest(request);
		if (result.authSuccess) this.mcp.establishConnection(result.serverId).catch((error) => {
			console.error("[Agent handleMcpOAuthCallback] Connection establishment failed:", error);
		});
		this.broadcastMcpServers();
		return this.handleOAuthCallbackResponse(result, request);
	}
	/**
	* Handle OAuth callback response using MCPClientManager configuration
	* @param result OAuth callback result
	* @param request The original request (needed for base URL)
	* @returns Response for the OAuth callback
	*/
	handleOAuthCallbackResponse(result, request) {
		const config = this.mcp.getOAuthCallbackConfig();
		if (config?.customHandler) return config.customHandler(result);
		const baseOrigin = new URL(request.url).origin;
		if (config?.successRedirect && result.authSuccess) try {
			return Response.redirect(new URL(config.successRedirect, baseOrigin).href);
		} catch (e) {
			console.error("Invalid successRedirect URL:", config.successRedirect, e);
			return Response.redirect(baseOrigin);
		}
		if (config?.errorRedirect && !result.authSuccess) try {
			const errorUrl = `${config.errorRedirect}?error=${encodeURIComponent(result.authError || "Unknown error")}`;
			return Response.redirect(new URL(errorUrl, baseOrigin).href);
		} catch (e) {
			console.error("Invalid errorRedirect URL:", config.errorRedirect, e);
			return Response.redirect(baseOrigin);
		}
		return Response.redirect(baseOrigin);
	}
};
const wrappedClasses = /* @__PURE__ */ new Set();
/**
* Route a request to the appropriate Agent
* @param request Request to route
* @param env Environment containing Agent bindings
* @param options Routing options
* @returns Response from the Agent or undefined if no route matched
*/
async function routeAgentRequest(request, env, options) {
	return routePartykitRequest(request, env, {
		prefix: "agents",
		...options
	});
}
const agentMapCache = /* @__PURE__ */ new WeakMap();
/**
* Route an email to the appropriate Agent
* @param email The email to route
* @param env The environment containing the Agent bindings
* @param options The options for routing the email
* @returns A promise that resolves when the email has been routed
*/
async function routeAgentEmail(email, env, options) {
	const routingInfo = await options.resolver(email, env);
	if (!routingInfo) {
		if (options.onNoRoute) await options.onNoRoute(email);
		else console.warn("No routing information found for email, dropping message");
		return;
	}
	if (!agentMapCache.has(env)) {
		const map = {};
		for (const [key, value] of Object.entries(env)) if (value && typeof value === "object" && "idFromName" in value && typeof value.idFromName === "function") {
			map[key] = value;
			map[camelCaseToKebabCase(key)] = value;
		}
		agentMapCache.set(env, map);
	}
	const agentMap = agentMapCache.get(env);
	const namespace = agentMap[routingInfo.agentName];
	if (!namespace) {
		const availableAgents = Object.keys(agentMap).filter((key) => !key.includes("-")).join(", ");
		throw new Error(`Agent namespace '${routingInfo.agentName}' not found in environment. Available agents: ${availableAgents}`);
	}
	const agent = await getAgentByName(namespace, routingInfo.agentId);
	const serialisableEmail = {
		getRaw: async () => {
			const reader = email.raw.getReader();
			const chunks = [];
			let done = false;
			while (!done) {
				const { value, done: readerDone } = await reader.read();
				done = readerDone;
				if (value) chunks.push(value);
			}
			const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
			const combined = new Uint8Array(totalLength);
			let offset = 0;
			for (const chunk of chunks) {
				combined.set(chunk, offset);
				offset += chunk.length;
			}
			return combined;
		},
		headers: email.headers,
		rawSize: email.rawSize,
		setReject: (reason) => {
			email.setReject(reason);
		},
		forward: (rcptTo, headers) => {
			return email.forward(rcptTo, headers);
		},
		reply: (replyOptions) => {
			return email.reply(new EmailMessage(replyOptions.from, replyOptions.to, replyOptions.raw));
		},
		from: email.from,
		to: email.to,
		_secureRouted: routingInfo._secureRouted
	};
	await agent._onEmail(serialisableEmail);
}
/**
* Get or create an Agent by name
* @template Env Environment type containing bindings
* @template T Type of the Agent class
* @param namespace Agent namespace
* @param name Name of the Agent instance
* @param options Options for Agent creation
* @returns Promise resolving to an Agent instance stub
*/
async function getAgentByName(namespace, name, options) {
	return getServerByName(namespace, name, options);
}
/**
* A wrapper for streaming responses in callable methods
*/
var StreamingResponse = class {
	constructor(connection, id) {
		this._closed = false;
		this._connection = connection;
		this._id = id;
	}
	/**
	* Whether the stream has been closed (via end() or error())
	*/
	get isClosed() {
		return this._closed;
	}
	/**
	* Send a chunk of data to the client
	* @param chunk The data to send
	* @returns false if stream is already closed (no-op), true if sent
	*/
	send(chunk) {
		if (this._closed) {
			console.warn("StreamingResponse.send() called after stream was closed - data not sent");
			return false;
		}
		const response = {
			done: false,
			id: this._id,
			result: chunk,
			success: true,
			type: MessageType.RPC
		};
		this._connection.send(JSON.stringify(response));
		return true;
	}
	/**
	* End the stream and send the final chunk (if any)
	* @param finalChunk Optional final chunk of data to send
	* @returns false if stream is already closed (no-op), true if sent
	*/
	end(finalChunk) {
		if (this._closed) return false;
		this._closed = true;
		const response = {
			done: true,
			id: this._id,
			result: finalChunk,
			success: true,
			type: MessageType.RPC
		};
		this._connection.send(JSON.stringify(response));
		return true;
	}
	/**
	* Send an error to the client and close the stream
	* @param message Error message to send
	* @returns false if stream is already closed (no-op), true if sent
	*/
	error(message) {
		if (this._closed) return false;
		this._closed = true;
		const response = {
			error: message,
			id: this._id,
			success: false,
			type: MessageType.RPC
		};
		this._connection.send(JSON.stringify(response));
		return true;
	}
};

//#endregion
export { Agent, DEFAULT_AGENT_STATIC_OPTIONS, SqlError, StreamingResponse, __DO_NOT_USE_WILL_BREAK__agentContext, callable, createHeaderBasedEmailResolver, getAgentByName, getCurrentAgent, routeAgentEmail, routeAgentRequest, unstable_callable };
//# sourceMappingURL=index.js.map