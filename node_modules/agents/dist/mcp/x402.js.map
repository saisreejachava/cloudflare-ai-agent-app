{"version":3,"file":"x402.js","names":[],"sources":["../../src/mcp/x402.ts"],"sourcesContent":["/**\n * X402 MCP Integration (v2)\n *\n * Based on:\n * - Coinbase's x402 (Apache 2.0): https://github.com/coinbase/x402\n * - @ethanniser and his work at https://github.com/ethanniser/x402-mcp\n */\n\nimport type {\n  McpServer,\n  RegisteredTool,\n  ToolCallback\n} from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Client as MCPClient } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type {\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  CallToolRequest,\n  CallToolResult,\n  ToolAnnotations\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { ZodRawShape } from \"zod\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\n\n// v2 imports from @x402/core\nimport { x402ResourceServer, HTTPFacilitatorClient } from \"@x402/core/server\";\nimport type { FacilitatorConfig, ResourceConfig } from \"@x402/core/server\";\nimport { x402Client } from \"@x402/core/client\";\nimport type {\n  PaymentPayload,\n  PaymentRequirements,\n  PaymentRequired,\n  Network\n} from \"@x402/core/types\";\n\n// v2 imports from @x402/evm\nimport { registerExactEvmScheme as registerServerEvmScheme } from \"@x402/evm/exact/server\";\nimport { registerExactEvmScheme as registerClientEvmScheme } from \"@x402/evm/exact/client\";\nimport type { ClientEvmSigner } from \"@x402/evm\";\n\n// Re-export commonly used types for consumer convenience\nexport type {\n  PaymentRequirements,\n  PaymentRequired,\n  Network\n} from \"@x402/core/types\";\nexport type { FacilitatorConfig } from \"@x402/core/server\";\nexport type { ClientEvmSigner } from \"@x402/evm\";\n\n/**\n * Map of legacy v1 network names to CAIP-2 identifiers.\n * Allows backward compatibility with v1 config.\n */\nconst LEGACY_NETWORK_MAP: Record<string, string> = {\n  \"base-sepolia\": \"eip155:84532\",\n  base: \"eip155:8453\",\n  ethereum: \"eip155:1\",\n  sepolia: \"eip155:11155111\"\n};\n\n/**\n * Normalize a network identifier to CAIP-2 format.\n * Accepts both legacy v1 names (\"base-sepolia\") and CAIP-2 (\"eip155:84532\").\n */\nexport function normalizeNetwork(network: string): Network {\n  return (LEGACY_NETWORK_MAP[network] ?? network) as Network;\n}\n\n/*\n  ======= SERVER SIDE =======\n*/\n\nexport type X402Config = {\n  /**\n   * Network identifier.\n   * Accepts both legacy names (\"base-sepolia\") and CAIP-2 format (\"eip155:84532\").\n   */\n  network: string;\n  /** Payment recipient address */\n  recipient: `0x${string}`;\n  /** Facilitator configuration. Defaults to https://x402.org/facilitator */\n  facilitator?: FacilitatorConfig;\n  /** @deprecated No longer used in v2. The protocol version is determined automatically. */\n  version?: number;\n};\n\nexport interface X402AugmentedServer {\n  paidTool<Args extends ZodRawShape>(\n    name: string,\n    description: string,\n    priceUSD: number,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback<Args>\n  ): RegisteredTool;\n}\n\nexport function withX402<T extends McpServer>(\n  server: T,\n  cfg: X402Config\n): T & X402AugmentedServer {\n  const network = normalizeNetwork(cfg.network);\n  const facilitatorConfig: FacilitatorConfig = cfg.facilitator ?? {\n    url: \"https://x402.org/facilitator\"\n  };\n\n  // Create v2 resource server with facilitator client\n  const facilitatorClient = new HTTPFacilitatorClient(facilitatorConfig);\n  const resourceServer = new x402ResourceServer(facilitatorClient);\n  registerServerEvmScheme(resourceServer);\n\n  // Lazy initialization: fetch supported kinds from facilitator on first use\n  let initPromise: Promise<void> | null = null;\n  function ensureInitialized(): Promise<void> {\n    if (!initPromise) {\n      initPromise = resourceServer.initialize().catch((err) => {\n        initPromise = null; // allow retry on failure\n        throw err;\n      });\n    }\n    return initPromise;\n  }\n\n  function paidTool<Args extends ZodRawShape>(\n    name: string,\n    description: string,\n    priceUSD: number,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback<Args>\n  ): RegisteredTool {\n    return server.registerTool(\n      name,\n      {\n        description,\n        inputSchema: paramsSchema,\n        annotations,\n        _meta: {\n          \"agents-x402/paymentRequired\": true,\n          \"agents-x402/priceUSD\": priceUSD\n        }\n      },\n      (async (args, extra) => {\n        await ensureInitialized();\n\n        // Build v2 payment requirements for this tool call\n        const resourceConfig: ResourceConfig = {\n          scheme: \"exact\",\n          payTo: cfg.recipient,\n          price: priceUSD,\n          network,\n          maxTimeoutSeconds: 300\n        };\n\n        let requirements: PaymentRequirements[];\n        try {\n          requirements =\n            await resourceServer.buildPaymentRequirements(resourceConfig);\n        } catch {\n          const payload = { x402Version: 2, error: \"PRICE_COMPUTE_FAILED\" };\n          return {\n            isError: true,\n            _meta: { \"x402/error\": payload },\n            content: [{ type: \"text\", text: JSON.stringify(payload) }]\n          } as const;\n        }\n\n        const resourceInfo = {\n          url: `x402://${name}`,\n          description,\n          mimeType: \"application/json\"\n        };\n\n        // Get payment token from MCP _meta or HTTP headers\n        // Support both v2 (PAYMENT-SIGNATURE) and v1 (X-PAYMENT) header names\n        const headers = extra?.requestInfo?.headers ?? {};\n        const token =\n          (extra?._meta?.[\"x402/payment\"] as string | undefined) ??\n          headers[\"PAYMENT-SIGNATURE\"] ??\n          headers[\"X-PAYMENT\"];\n\n        const paymentRequired = (\n          reason = \"PAYMENT_REQUIRED\",\n          extraFields: Record<string, unknown> = {}\n        ) => {\n          const payload = {\n            x402Version: 2,\n            error: reason,\n            resource: resourceInfo,\n            accepts: requirements,\n            ...extraFields\n          };\n          return {\n            isError: true,\n            _meta: { \"x402/error\": payload },\n            content: [{ type: \"text\", text: JSON.stringify(payload) }]\n          } as const;\n        };\n\n        if (!token || typeof token !== \"string\") return paymentRequired();\n\n        // Decode the payment payload (base64-encoded JSON)\n        let paymentPayload: PaymentPayload;\n        try {\n          paymentPayload = JSON.parse(atob(token));\n        } catch {\n          return paymentRequired(\"INVALID_PAYMENT\");\n        }\n\n        // Find matching requirements for this payment\n        const matchingReq = resourceServer.findMatchingRequirements(\n          requirements,\n          paymentPayload\n        );\n        if (!matchingReq) {\n          return paymentRequired(\"INVALID_PAYMENT\");\n        }\n\n        // Verify payment with facilitator\n        try {\n          const vr = await resourceServer.verifyPayment(\n            paymentPayload,\n            matchingReq\n          );\n          if (!vr.isValid) {\n            return paymentRequired(vr.invalidReason ?? \"INVALID_PAYMENT\", {\n              payer: vr.payer\n            });\n          }\n        } catch {\n          return paymentRequired(\"INVALID_PAYMENT\");\n        }\n\n        // Execute the tool callback\n        let result: CallToolResult;\n        let failed = false;\n        try {\n          result = await cb(args, extra);\n          if (\n            result &&\n            typeof result === \"object\" &&\n            \"isError\" in result &&\n            result.isError\n          ) {\n            failed = true;\n          }\n        } catch (e) {\n          failed = true;\n          result = {\n            isError: true,\n            content: [\n              { type: \"text\", text: `Tool execution failed: ${String(e)}` }\n            ]\n          };\n        }\n\n        // Settle payment only on success\n        if (!failed) {\n          try {\n            const s = await resourceServer.settlePayment(\n              paymentPayload,\n              matchingReq\n            );\n            if (s.success) {\n              result._meta ??= {};\n              result._meta[\"x402/payment-response\"] = {\n                success: true,\n                transaction: s.transaction,\n                network: s.network,\n                payer: s.payer\n              };\n            } else {\n              return paymentRequired(s.errorReason ?? \"SETTLEMENT_FAILED\");\n            }\n          } catch {\n            return paymentRequired(\"SETTLEMENT_FAILED\");\n          }\n        }\n\n        return result;\n      }) as ToolCallback<Args>\n    );\n  }\n\n  Object.defineProperty(server, \"paidTool\", {\n    value: paidTool,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  // Tell TS the object now also has the paidTool method\n  return server as T & X402AugmentedServer;\n}\n\n/*\n  ======= CLIENT SIDE =======\n*/\n\nexport interface X402AugmentedClient {\n  callTool(\n    x402ConfirmationCallback:\n      | ((payment: PaymentRequirements[]) => Promise<boolean>)\n      | null,\n    params: CallToolRequest[\"params\"],\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ): Promise<CallToolResult>;\n}\n\nexport type X402ClientConfig = {\n  /**\n   * EVM account/signer for signing payment authorizations.\n   * Use `privateKeyToAccount()` from viem/accounts to create one.\n   */\n  account: ClientEvmSigner;\n  /**\n   * Preferred network identifier (optional).\n   * Accepts both legacy names (\"base-sepolia\") and CAIP-2 format (\"eip155:84532\").\n   * When set, the client prefers payment requirements matching this network.\n   * If omitted, the client automatically selects from available requirements.\n   */\n  network?: string;\n  /** Maximum payment value in atomic units (default: 0.10 USDC = 100000) */\n  maxPaymentValue?: bigint;\n  /** @deprecated No longer used in v2. The protocol version is determined automatically. */\n  version?: number;\n  /** Confirmation callback for payment approval */\n  confirmationCallback?: (payment: PaymentRequirements[]) => Promise<boolean>;\n};\n\nexport function withX402Client<T extends MCPClient>(\n  client: T,\n  x402Config: X402ClientConfig\n): X402AugmentedClient & T {\n  const { account } = x402Config;\n\n  const maxPaymentValue = x402Config.maxPaymentValue ?? BigInt(100_000); // 0.10 USDC\n\n  // Create v2 x402 payment client with EVM scheme support\n  const paymentClient = new x402Client();\n  registerClientEvmScheme(paymentClient, { signer: account });\n\n  // If a preferred network is specified, register a policy to prefer it\n  if (x402Config.network) {\n    const preferredNetwork = normalizeNetwork(x402Config.network);\n    paymentClient.registerPolicy((_version, reqs) => {\n      const matching = reqs.filter((r) => r.network === preferredNetwork);\n      return matching.length > 0 ? matching : reqs;\n    });\n  }\n\n  const _listTools = client.listTools.bind(client);\n\n  // Wrap the original method to include payment information in the description\n  const listTools: typeof _listTools = async (params, options) => {\n    const toolsRes = await _listTools(params, options);\n    return {\n      ...toolsRes,\n      tools: toolsRes.tools.map((tool) => {\n        let description = tool.description;\n        // Check _meta for payment information (agents-x402/ is our extension for pre-advertising prices)\n        if (tool._meta?.[\"agents-x402/paymentRequired\"]) {\n          const cost = tool._meta?.[\"agents-x402/priceUSD\"]\n            ? `$${tool._meta?.[\"agents-x402/priceUSD\"]}`\n            : \"an unknown amount\";\n          description += ` (This is a paid tool, you will be charged ${cost} for its execution)`;\n        }\n        return {\n          ...tool,\n          description\n        };\n      })\n    };\n  };\n\n  const _callTool = client.callTool.bind(client);\n\n  const callToolWithPayment = async (\n    x402ConfirmationCallback:\n      | ((payment: PaymentRequirements[]) => Promise<boolean>)\n      | null,\n    params: CallToolRequest[\"params\"],\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ): ReturnType<typeof client.callTool> => {\n    // Call the tool\n    const res = await _callTool(params, resultSchema, options);\n\n    // Check for x402 payment required error in response metadata\n    const maybeX402Error = res._meta?.[\"x402/error\"] as\n      | (PaymentRequired & Record<string, unknown>)\n      | undefined;\n\n    if (\n      res.isError &&\n      maybeX402Error &&\n      maybeX402Error.accepts &&\n      Array.isArray(maybeX402Error.accepts) &&\n      maybeX402Error.accepts.length > 0\n    ) {\n      const accepts = maybeX402Error.accepts;\n      const confirmationCallback =\n        x402ConfirmationCallback ?? x402Config.confirmationCallback;\n\n      // Use the confirmation callback if provided\n      if (confirmationCallback && !(await confirmationCallback(accepts))) {\n        return {\n          isError: true,\n          content: [{ type: \"text\", text: \"User declined payment\" }]\n        };\n      }\n\n      // Check max payment value against the first requirement's amount\n      const selectedReq = accepts[0];\n      if (!selectedReq || selectedReq.scheme !== \"exact\") return res;\n\n      let amount: bigint;\n      try {\n        amount = BigInt(selectedReq.amount);\n      } catch {\n        return res; // malformed amount â€” return original error\n      }\n      if (amount > maxPaymentValue) {\n        return {\n          isError: true,\n          content: [\n            {\n              type: \"text\",\n              text: `Payment exceeds client cap: ${amount} > ${maxPaymentValue}`\n            }\n          ]\n        };\n      }\n\n      // Reconstruct the PaymentRequired response for the v2 x402 client\n      const paymentRequiredResponse: PaymentRequired = {\n        x402Version: (maybeX402Error.x402Version as number) ?? 2,\n        resource: (maybeX402Error.resource as PaymentRequired[\"resource\"]) ?? {\n          url: \"\",\n          description: \"\",\n          mimeType: \"application/json\"\n        },\n        accepts,\n        extensions: maybeX402Error.extensions as\n          | Record<string, unknown>\n          | undefined\n      };\n\n      // Create the payment payload using the v2 x402 client\n      let paymentPayload: PaymentPayload;\n      try {\n        paymentPayload = await paymentClient.createPaymentPayload(\n          paymentRequiredResponse\n        );\n      } catch {\n        return {\n          isError: true,\n          content: [{ type: \"text\", text: \"Failed to create payment payload\" }]\n        };\n      }\n\n      // Encode the payment payload as a base64 JSON token for MCP transport\n      const token = btoa(JSON.stringify(paymentPayload));\n\n      // Retry the tool call with the payment token\n      return _callTool(\n        {\n          ...params,\n          _meta: {\n            ...params._meta,\n            \"x402/payment\": token\n          }\n        },\n        resultSchema,\n        options\n      );\n    }\n\n    return res;\n  };\n\n  const _client = client as X402AugmentedClient & T;\n  Object.defineProperty(_client, \"listTools\", {\n    value: listTools,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_client, \"callTool\", {\n    value: callToolWithPayment,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return _client;\n}\n"],"mappings":"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"}