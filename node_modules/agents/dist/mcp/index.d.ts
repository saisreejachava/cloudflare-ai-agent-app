import { a as BaseTransportType, c as ServeOptions, o as CORSOptions, s as MaybePromise } from "../client-storage-Cvy5r9FG.js";
import { MCPClientOAuthCallbackConfig, MCPClientOAuthResult, MCPConnectionResult, MCPDiscoverResult, MCPServerOptions } from "./client.js";
import { Agent, Connection, ConnectionContext } from "../index.js";
import { SSEClientTransport, SSEClientTransportOptions } from "@modelcontextprotocol/sdk/client/sse.js";
import { StreamableHTTPClientTransport, StreamableHTTPClientTransportOptions } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { ElicitRequest, ElicitRequestSchema, ElicitResult, ElicitResult as ElicitResult$1, InitializeRequestParams, JSONRPCMessage, MessageExtraInfo, RequestId } from "@modelcontextprotocol/sdk/types.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { Transport, TransportSendOptions } from "@modelcontextprotocol/sdk/shared/transport.js";
import { EventStore } from "@modelcontextprotocol/sdk/server/streamableHttp.js";

//#region src/mcp/client-transports.d.ts
/**
 * @deprecated Use SSEClientTransport from @modelcontextprotocol/sdk/client/sse.js instead. This alias will be removed in the next major version.
 */
declare class SSEEdgeClientTransport extends SSEClientTransport {
  constructor(url: URL, options: SSEClientTransportOptions);
}
/**
 * @deprecated Use StreamableHTTPClientTransport from @modelcontextprotocol/sdk/client/streamableHttp.js instead. This alias will be removed in the next major version.
 */
declare class StreamableHTTPEdgeClientTransport extends StreamableHTTPClientTransport {
  constructor(url: URL, options: StreamableHTTPClientTransportOptions);
}
//#endregion
//#region src/mcp/worker-transport.d.ts
interface MCPStorageApi {
  get(): Promise<TransportState | undefined> | TransportState | undefined;
  set(state: TransportState): Promise<void> | void;
}
interface TransportState {
  sessionId?: string;
  initialized: boolean;
  initializeParams?: InitializeRequestParams;
}
interface WorkerTransportOptions {
  /**
   * Function that generates a session ID for the transport.
   * The session ID SHOULD be globally unique and cryptographically secure.
   * Return undefined to disable session management (stateless mode).
   */
  sessionIdGenerator?: () => string;
  /**
   * Enable traditional Request/Response mode, this will disable streaming.
   */
  enableJsonResponse?: boolean;
  /**
   * Callback fired when a new session is initialized.
   */
  onsessioninitialized?: (sessionId: string) => void;
  /**
   * Callback fired when a session is closed via DELETE request.
   */
  onsessionclosed?: (sessionId: string) => void;
  corsOptions?: CORSOptions;
  /**
   * Optional storage api for persisting transport state.
   * Use this to store session state in Durable Object/Agent storage
   * so it survives hibernation/restart.
   */
  storage?: MCPStorageApi;
  /**
   * Event store for resumability support.
   * If provided, enables clients to reconnect and resume messages using Last-Event-ID.
   */
  eventStore?: EventStore;
  /**
   * Retry interval in milliseconds to suggest to clients in SSE retry field.
   * Controls client reconnection timing for polling behavior.
   */
  retryInterval?: number;
}
declare class WorkerTransport implements Transport {
  started: boolean;
  private initialized;
  private sessionIdGenerator?;
  private enableJsonResponse;
  private onsessioninitialized?;
  private onsessionclosed?;
  private standaloneSseStreamId;
  private streamMapping;
  private requestToStreamMapping;
  private requestResponseMap;
  private corsOptions?;
  private storage?;
  private stateRestored;
  private eventStore?;
  private retryInterval?;
  private initializeParams?;
  sessionId?: string;
  onclose?: () => void;
  onerror?: (error: Error) => void;
  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;
  constructor(options?: WorkerTransportOptions);
  /**
   * Restore transport state from persistent storage.
   * This is automatically called on start.
   */
  private restoreState;
  /**
   * Persist current transport state to storage.
   */
  private saveState;
  start(): Promise<void>;
  /**
   * Validates the MCP-Protocol-Version header on incoming requests.
   *
   * This performs a simple check: if a version header is present, it must be
   * in the SUPPORTED_PROTOCOL_VERSIONS list. We do not track the negotiated
   * version or enforce version consistency across requests - the SDK handles
   * version negotiation during initialization, and we simply reject any
   * explicitly unsupported versions.
   *
   * - Header present and supported: Accept
   * - Header present and unsupported: 400 Bad Request
   * - Header missing: Accept (version validation is optional)
   */
  private validateProtocolVersion;
  private getHeaders;
  handleRequest(request: Request, parsedBody?: unknown): Promise<Response>;
  private handleGetRequest;
  private handlePostRequest;
  private handleDeleteRequest;
  private handleOptionsRequest;
  private handleUnsupportedRequest;
  private validateSession;
  close(): Promise<void>;
  /**
   * Close an SSE stream for a specific request, triggering client reconnection.
   * Use this to implement polling behavior during long-running operations -
   * client will reconnect after the retry interval specified in the priming event.
   */
  closeSSEStream(requestId: RequestId): void;
  send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void>;
}
//#endregion
//#region src/mcp/auth-context.d.ts
interface McpAuthContext {
  props: Record<string, unknown>;
}
declare function getMcpAuthContext(): McpAuthContext | undefined;
//#endregion
//#region src/mcp/handler.d.ts
interface CreateMcpHandlerOptions extends WorkerTransportOptions {
  /**
   * The route path that this MCP handler should respond to.
   * If specified, the handler will only process requests that match this route.
   * @default "/mcp"
   */
  route?: string;
  /**
   * An optional auth context to use for handling MCP requests.
   * If not provided, the handler will look for props in the execution context.
   */
  authContext?: McpAuthContext;
  /**
   * An optional transport to use for handling MCP requests.
   * If not provided, a WorkerTransport will be created with the provided WorkerTransportOptions.
   */
  transport?: WorkerTransport;
}
declare function createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
/**
 * @deprecated This has been renamed to createMcpHandler, and experimental_createMcpHandler will be removed in the next major version
 */
declare function experimental_createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
//#endregion
//#region src/mcp/index.d.ts
declare abstract class McpAgent<Env extends Cloudflare.Env = Cloudflare.Env, State = unknown, Props extends Record<string, unknown> = Record<string, unknown>> extends Agent<Env, State, Props> {
  private _transport?;
  props?: Props;
  abstract server: MaybePromise<McpServer | Server>;
  abstract init(): Promise<void>;
  setInitializeRequest(initializeRequest: JSONRPCMessage): Promise<void>;
  getInitializeRequest(): Promise<JSONRPCMessage | undefined>;
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType(): BaseTransportType;
  /** Read the sessionId for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getSessionId(): string;
  /** Get the unique WebSocket. SSE transport only. */
  getWebSocket(): Connection<unknown> | null;
  /** Returns a new transport matching the type of the Agent. */
  private initTransport;
  /** Update and store the props */
  updateProps(props?: Props): Promise<void>;
  reinitializeServer(): Promise<void>;
  /** Sets up the MCP transport and server every time the Agent is started.*/
  onStart(props?: Props): Promise<void>;
  /** Validates new WebSocket connections. */
  onConnect(conn: Connection, {
    request: req
  }: ConnectionContext): Promise<void>;
  /** Handles MCP Messages for the legacy SSE transport. */
  onSSEMcpMessage(_sessionId: string, messageBody: unknown, extraInfo?: MessageExtraInfo): Promise<Error | null>;
  /** Elicit user input with a message and schema */
  elicitInput(params: {
    message: string;
    requestedSchema: unknown;
  }): Promise<ElicitResult$1>;
  /** Wait for elicitation response through storage polling */
  private _waitForElicitationResponse;
  /** Handle elicitation responses */
  private _handleElicitationResponse;
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path: string, {
    binding,
    corsOptions,
    transport,
    jurisdiction
  }?: ServeOptions): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  /**
   * Legacy api
   **/
  static mount(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  static serveSSE(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
}
//#endregion
export { type CreateMcpHandlerOptions, type ElicitRequest, ElicitRequestSchema, type ElicitResult, type MCPClientOAuthCallbackConfig, type MCPClientOAuthResult, type MCPConnectionResult, type MCPDiscoverResult, type MCPServerOptions, McpAgent, type McpAuthContext, SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport, type TransportState, WorkerTransport, type WorkerTransportOptions, createMcpHandler, experimental_createMcpHandler, getMcpAuthContext };
//# sourceMappingURL=index.d.ts.map