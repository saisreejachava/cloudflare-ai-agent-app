import { t as MCPObservabilityEvent } from "./mcp-Dw5vDrY8.js";
import { AgentMcpOAuthProvider } from "./mcp/do-oauth-client-provider.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import {
  SSEClientTransport,
  SSEClientTransportOptions
} from "@modelcontextprotocol/sdk/client/sse.js";
import {
  StreamableHTTPClientTransport,
  StreamableHTTPClientTransportOptions
} from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import {
  ElicitRequest,
  ElicitResult,
  Prompt,
  Resource,
  ResourceTemplate,
  ServerCapabilities,
  Tool
} from "@modelcontextprotocol/sdk/types.js";

//#region src/core/events.d.ts
interface Disposable {
  dispose(): void;
}
type Event<T> = (listener: (e: T) => void) => Disposable;
declare class Emitter<T> implements Disposable {
  private _listeners;
  readonly event: Event<T>;
  fire(data: T): void;
  dispose(): void;
}
//#endregion
//#region src/mcp/types.d.ts
type MaybePromise<T> = T | Promise<T>;
type BaseTransportType = "sse" | "streamable-http";
type TransportType = BaseTransportType | "auto";
interface CORSOptions {
  origin?: string;
  methods?: string;
  headers?: string;
  maxAge?: number;
  exposeHeaders?: string;
}
interface ServeOptions {
  binding?: string;
  corsOptions?: CORSOptions;
  transport?: BaseTransportType;
  jurisdiction?: DurableObjectJurisdiction;
}
//#endregion
//#region src/mcp/client-connection.d.ts
/**
 * Connection state machine for MCP client connections.
 *
 * State transitions:
 * - Non-OAuth: init() → CONNECTING → DISCOVERING → READY
 * - OAuth: init() → AUTHENTICATING → (callback) → CONNECTING → DISCOVERING → READY
 * - Any state can transition to FAILED on error
 */
declare const MCPConnectionState: {
  /** Waiting for OAuth authorization to complete */ readonly AUTHENTICATING: "authenticating" /** Establishing transport connection to MCP server */;
  readonly CONNECTING: "connecting" /** Transport connection established */;
  readonly CONNECTED: "connected" /** Discovering server capabilities (tools, resources, prompts) */;
  readonly DISCOVERING: "discovering" /** Fully connected and ready to use */;
  readonly READY: "ready" /** Connection failed at some point */;
  readonly FAILED: "failed";
};
/**
 * Connection state type for MCP client connections.
 */
type MCPConnectionState =
  (typeof MCPConnectionState)[keyof typeof MCPConnectionState];
type MCPTransportOptions = (
  | SSEClientTransportOptions
  | StreamableHTTPClientTransportOptions
) & {
  authProvider?: AgentMcpOAuthProvider;
  type?: TransportType;
};
/**
 * Result of a discovery operation.
 * success indicates whether discovery completed successfully.
 * error is present when success is false.
 */
type MCPDiscoveryResult = {
  success: boolean;
  error?: string;
};
declare class MCPClientConnection {
  url: URL;
  options: {
    transport: MCPTransportOptions;
    client: ConstructorParameters<typeof Client>[1];
  };
  client: Client;
  connectionState: MCPConnectionState;
  connectionError: string | null;
  lastConnectedTransport: BaseTransportType | undefined;
  instructions?: string;
  tools: Tool[];
  prompts: Prompt[];
  resources: Resource[];
  resourceTemplates: ResourceTemplate[];
  serverCapabilities: ServerCapabilities | undefined;
  /** Tracks in-flight discovery to allow cancellation */
  private _discoveryAbortController;
  private readonly _onObservabilityEvent;
  readonly onObservabilityEvent: Event<MCPObservabilityEvent>;
  constructor(
    url: URL,
    info: ConstructorParameters<typeof Client>[0],
    options?: {
      transport: MCPTransportOptions;
      client: ConstructorParameters<typeof Client>[1];
    }
  );
  /**
   * Initialize a client connection, if authentication is required, the connection will be in the AUTHENTICATING state
   * Sets connection state based on the result and emits observability events
   *
   * @returns Error message if connection failed, undefined otherwise
   */
  init(): Promise<string | undefined>;
  /**
   * Finish OAuth by probing transports based on configured type.
   * - Explicit: finish on that transport
   * - Auto: try streamable-http, then sse on 404/405/Not Implemented
   */
  private finishAuthProbe;
  /**
   * Complete OAuth authorization
   */
  completeAuthorization(code: string): Promise<void>;
  /**
   * Discover server capabilities and register tools, resources, prompts, and templates.
   * This method does the work but does not manage connection state - that's handled by discover().
   */
  discoverAndRegister(): Promise<void>;
  /**
   * Discover server capabilities with timeout and cancellation support.
   * If called while a previous discovery is in-flight, the previous discovery will be aborted.
   *
   * @param options Optional configuration
   * @param options.timeoutMs Timeout in milliseconds (default: 15000)
   * @returns Result indicating success/failure with optional error message
   */
  discover(options?: { timeoutMs?: number }): Promise<MCPDiscoveryResult>;
  /**
   * Cancel any in-flight discovery operation.
   * Called when closing the connection.
   */
  cancelDiscovery(): void;
  /**
   * Notification handler registration for tools
   * Should only be called if serverCapabilities.tools exists
   */
  registerTools(): Promise<Tool[]>;
  /**
   * Notification handler registration for resources
   * Should only be called if serverCapabilities.resources exists
   */
  registerResources(): Promise<Resource[]>;
  /**
   * Notification handler registration for prompts
   * Should only be called if serverCapabilities.prompts exists
   */
  registerPrompts(): Promise<Prompt[]>;
  registerResourceTemplates(): Promise<ResourceTemplate[]>;
  fetchTools(): Promise<
    {
      inputSchema: {
        [x: string]: unknown;
        type: "object";
        properties?:
          | {
              [x: string]: object;
            }
          | undefined;
        required?: string[] | undefined;
      };
      name: string;
      description?: string | undefined;
      outputSchema?:
        | {
            [x: string]: unknown;
            type: "object";
            properties?:
              | {
                  [x: string]: object;
                }
              | undefined;
            required?: string[] | undefined;
          }
        | undefined;
      annotations?:
        | {
            title?: string | undefined;
            readOnlyHint?: boolean | undefined;
            destructiveHint?: boolean | undefined;
            idempotentHint?: boolean | undefined;
            openWorldHint?: boolean | undefined;
          }
        | undefined;
      execution?:
        | {
            taskSupport?: "optional" | "required" | "forbidden" | undefined;
          }
        | undefined;
      _meta?:
        | {
            [x: string]: unknown;
          }
        | undefined;
      icons?:
        | {
            src: string;
            mimeType?: string | undefined;
            sizes?: string[] | undefined;
            theme?: "light" | "dark" | undefined;
          }[]
        | undefined;
      title?: string | undefined;
    }[]
  >;
  fetchResources(): Promise<
    {
      uri: string;
      name: string;
      description?: string | undefined;
      mimeType?: string | undefined;
      annotations?:
        | {
            audience?: ("user" | "assistant")[] | undefined;
            priority?: number | undefined;
            lastModified?: string | undefined;
          }
        | undefined;
      _meta?:
        | {
            [x: string]: unknown;
          }
        | undefined;
      icons?:
        | {
            src: string;
            mimeType?: string | undefined;
            sizes?: string[] | undefined;
            theme?: "light" | "dark" | undefined;
          }[]
        | undefined;
      title?: string | undefined;
    }[]
  >;
  fetchPrompts(): Promise<
    {
      name: string;
      description?: string | undefined;
      arguments?:
        | {
            name: string;
            description?: string | undefined;
            required?: boolean | undefined;
          }[]
        | undefined;
      _meta?:
        | {
            [x: string]: unknown;
          }
        | undefined;
      icons?:
        | {
            src: string;
            mimeType?: string | undefined;
            sizes?: string[] | undefined;
            theme?: "light" | "dark" | undefined;
          }[]
        | undefined;
      title?: string | undefined;
    }[]
  >;
  fetchResourceTemplates(): Promise<
    {
      uriTemplate: string;
      name: string;
      description?: string | undefined;
      mimeType?: string | undefined;
      annotations?:
        | {
            audience?: ("user" | "assistant")[] | undefined;
            priority?: number | undefined;
            lastModified?: string | undefined;
          }
        | undefined;
      _meta?:
        | {
            [x: string]: unknown;
          }
        | undefined;
      icons?:
        | {
            src: string;
            mimeType?: string | undefined;
            sizes?: string[] | undefined;
            theme?: "light" | "dark" | undefined;
          }[]
        | undefined;
      title?: string | undefined;
    }[]
  >;
  /**
   * Handle elicitation request from server
   * Automatically uses the Agent's built-in elicitation handling if available
   */
  handleElicitationRequest(_request: ElicitRequest): Promise<ElicitResult>;
  /**
   * Get the transport for the client
   * @param transportType - The transport type to get
   * @returns The transport for the client
   */
  getTransport(
    transportType: BaseTransportType
  ): StreamableHTTPClientTransport | SSEClientTransport;
  private tryConnect;
  private _capabilityErrorHandler;
}
//#endregion
//#region src/mcp/client-storage.d.ts
/**
 * Represents a row in the cf_agents_mcp_servers table
 */
type MCPServerRow = {
  id: string;
  name: string;
  server_url: string;
  client_id: string | null;
  auth_url: string | null;
  callback_url: string;
  server_options: string | null;
};
//#endregion
export {
  BaseTransportType as a,
  ServeOptions as c,
  Event as d,
  MCPTransportOptions as i,
  TransportType as l,
  MCPClientConnection as n,
  CORSOptions as o,
  MCPConnectionState as r,
  MaybePromise as s,
  MCPServerRow as t,
  Emitter as u
};
//# sourceMappingURL=client-storage-Cvy5r9FG.d.ts.map
